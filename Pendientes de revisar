#MLM, MLG, MLGM con covariables, PCA

paquetes <- c(
  "openxlsx", "fBasics", "psych", "modeest", "ggrepel", "GGally", 
  "mice", "corrplot", "readxl", "doebioresearch", "performance", "dplyr", 
  "ScottKnott", "agricolae", "car", "broom", "data.table", "emmeans", 
  "ggplot2", "tidyverse", "lattice", "nlme", "lme4", "lmerTest", "multcomp", 
  "rstatix", "ggpubr", "see", "MASS", "lsmeans", "scales", "lmtest", "multcompView", 
  "googlesheets4", "googledrive", "clipr", "FactoMineR", "factoextra", 
  "glmmTMB", "DHARMa", "MuMIn", "hnp", "effects", "sjstats", "ExpDes", "sf", "tmap", "terra",
  "RVAideMemoire", "RColorBrewer", "DiagrammeR", "missMDA", "FSA", "coin", "PMCMRplus", "rcompanion",
  "DescTools", "ResourceSelection")


# Verifica cuáles no están instalados
no_instalados <- paquetes[!(paquetes %in% installed.packages()[,"Package"])];no_instalados

# Instala los que faltan
if(length(no_instalados)) {
  install.packages(no_instalados)
} else {
  message("Todos los paquetes ya están instalados.")
}

# Carga todos los paquetes (opcional)
lapply(paquetes, library, character.only = TRUE)
#-----------------------------------------------------------------------------------------------
archivo <- file.choose() #Abrir el archivo Excel  
hojas <- excel_sheets(archivo); hojas
for (h in hojas) {
  cat("\n--- Hoja:", h, "---\n")
  datos_hoja <- read_excel(archivo, sheet = h, n_max = 10)  # solo primeras 5 filas
  print(datos_hoja)
}
datos <- read_excel(archivo, sheet = 5)
attach(datos)
colnames(datos)



##--Modelo lineal mixto (MLM)-------------------------------------------

colnames(datos)

respuestas <- c("Altura", "Diametro", "Peso", "Tallos_Ha", "Peso_Total", "TCH_Est")

#-----------------------------
# Definir efectos
#-----------------------------
efectos_fijos <- c("Tratamiento")
efectos_aleatorios <- c("(1 | Replica)")

# Definir efecto fijo para PMM
efecto_fijo_pmm <- efectos_fijos[1]  # ahora sí está definido
efectos_fijos_pmm_graficos <- efectos_fijos  # para gráficos

# Convertir factores
factores <- c("Tratamiento")
for(f in factores){
  if(f %in% colnames(datos)) datos[[f]] <- factor(datos[[f]])
}

#-----------------------------
# Bucle completo para todas las variables
#-----------------------------
for(var in respuestas){
  cat("\n====================================\n")
  cat("Variable:", var, "\n")
  cat("====================================\n")
  
  # Construir fórmula
  fixed_str <- paste(efectos_fijos, collapse = " + ")
  random_str <- paste(efectos_aleatorios, collapse = " + ")
  formula <- as.formula(paste0(var, " ~ ", fixed_str, " + ", random_str))
  
  # Ajustar modelo
  modelo <- lmer(formula, data = datos, REML = TRUE)
  
  # Resultados
  print(summary(modelo))
  print(anova(modelo))
  
  #-----------------------------
  # Verificación de supuestos
  #-----------------------------
  
  sim_res <- simulateResiduals(modelo)
  trat <- model.frame(modelo)$Tratamiento
  plotResiduals(sim_res, form = trat)
  plot(sim_res)
  
  cat("\nShapiro-Wilk de residuos simulados:\n")
  print(shapiro.test(residuals(sim_res)))
  
  fitted_vals <- fitted(modelo)
  resids <- resid(modelo)
  
  p1 <- ggplot(data.frame(Fitted=fitted_vals, Resid=resids), aes(x=Fitted, y=Resid)) +
    geom_point() + geom_hline(yintercept=0, linetype="dashed", color="red") +
    labs(title=paste("Residuos vs Ajustados:", var))
  print(p1)
  
  p2 <- ggplot(data.frame(Order=1:length(resids), Resid=resids), aes(x=Order, y=Resid)) +
    geom_point() + geom_hline(yintercept=0, linetype="dashed", color="red") +
    labs(title=paste("Residuos vs Orden:", var))
  print(p2)
  
  cat("\nACF de residuos:\n")
  acf(resids, main=paste("ACF de residuos:", var))
}

#--------------------------------------------PMM (Tukey)------------------------------------------
for(var in respuestas){
  cat("\n====================================\n")
  cat("Análisis PMM para la variable:", var, "\n")
  cat("====================================\n")
  
  # Ajustar modelo lineal mixto
  formula <- as.formula(paste0(var, " ~ ", efecto_fijo_pmm, " + ", paste(efectos_aleatorios, collapse=" + ")))
  modelo <- lmer(formula, data = datos, REML = TRUE)
  
  # Medias marginales estimadas
  emmeans_var <- emmeans(modelo, as.formula(paste0("~", efecto_fijo_pmm)))
  
  # Comparación por pares (Tukey)
  comparaciones_pares <- pairs(emmeans_var, adjust = "tukey")
  print(summary(comparaciones_pares))
  
  # Letras de agrupamiento
  letras <- cld(emmeans_var, Letters = letters, adjust="tukey")
  print(letras)
  
  # Gráfico de barras con letras de agrupamiento
  resumen_letras <- as.data.frame(letras)
  p <- ggplot(resumen_letras, aes(x=.data[[efecto_fijo_pmm]], y=emmean)) +
    geom_bar(stat="identity", fill="steelblue", alpha=0.7) +
    geom_errorbar(aes(ymin=lower.CL, ymax=upper.CL), width=0.2) +
    geom_text(aes(label=.group, y=emmean), vjust=-0.5, size=4) +
    labs(title=paste("Medias Estimadas y Agrupamiento Tukey:", var),
         x=efecto_fijo_pmm, y="Media Estimada (EMMean)") +
    theme_minimal()
  print(p)
}

#------------------Gráficos--------------------------------------------------
if(length(efectos_fijos_pmm_graficos) > 0){
  for(var in respuestas){
    # Barras con promedio
    ggplot(datos, aes(x=.data[[efectos_fijos_pmm_graficos[1]]], y=.data[[var]], fill=.data[[efectos_fijos_pmm_graficos[1]]])) +
      geom_bar(stat="summary", fun="mean") +
      labs(title=paste("Gráfico de barras:", var), y=var) +
      theme_minimal() -> p
    print(p)
    
    # Barras con error
    resumen <- datos %>%
      group_by(.data[[efectos_fijos_pmm_graficos[1]]]) %>%
      summarise(Media=mean(.data[[var]], na.rm=TRUE),
                SD=sd(.data[[var]], na.rm=TRUE), .groups='drop')
    
    ggplot(resumen, aes(x=.data[[efectos_fijos_pmm_graficos[1]]], y=Media, fill=.data[[efectos_fijos_pmm_graficos[1]]])) +
      geom_bar(stat="identity") +
      geom_errorbar(aes(ymin=Media-SD, ymax=Media+SD), width=0.2) +
      geom_point(aes(y=Media), color="black", size=3) +
      coord_flip() +
      labs(title=paste("Gráfico de barras con error:", var), y=var) +
      theme_minimal() -> p
    print(p)
    
    # Histograma
    ggplot(datos, aes(x=.data[[var]])) +
      geom_histogram(binwidth=diff(range(datos[[var]], na.rm=TRUE))/20,
                     fill="steelblue", color="black", alpha=0.7) +
      labs(title=paste("Histograma:", var), x=var, y="Frecuencia") +
      theme_minimal() -> p
    print(p)
  }
}


########################################################################################
shapiroTest(c(Altura, Diametro, Peso, Tallos_Ha, Peso_Total, TCH_Est))

shapiroTest(TCH_Est)
shapiroTest()

library(lme4)

modelo_gamma <- glm(Altura ~ Tratamiento + Replica, data = datos, family = Gamma(link = "log"))
summary(modelo_gamma)
Anova(modelo_gamma, type=3) 

library(DHARMa)

sim_res <- simulateResiduals(modelo_gamma)
plot(sim_res)   # te da QQ-plot, dispersión y uniformidad


#########################################--PCA--#############################################################


# Seleccionamos solo las variables cuantitativas
variables <- datos[, respuestas]

# Imputamos los NA usando PCA (elige ncp = número de componentes a estimar, ej: 2)
imput <- imputePCA(variables, ncp = 2)  

# Extraemos los datos imputados
variables_imputadas <- imput$completeObs

# Ejecutamos PCA con las variables imputadas
pca <- PCA(variables_imputadas, scale.unit = TRUE, graph = FALSE)

# -------------------------------
# Gráfico de individuos
# -------------------------------
fviz_pca_ind(pca, 
             geom.ind = "point",
             col.ind = datos$Tratamiento,   # variable categórica para colorear
             palette = "jco",
             addEllipses = TRUE,
             legend.title = "Grupo")

# -------------------------------
# Biplot (individuos + variables)
# -------------------------------
fviz_pca_biplot(pca, 
                col.ind = datos$Tratamiento,
                palette = "jco",
                addEllipses = TRUE,
                label = "var",
                col.var = "black")

# -------------------------------
# Biplot
# -------------------------------
fviz_pca_var(pca,
             col.var = "contrib",      # colorea según contribución al eje
             gradient.cols = c("blue", "blue", "red"),
             repel = TRUE)             # evita que se sobrepongan etiquetas





















#######################################################--Análisis de componentes principales (PCA)
colnames(datos)
variables <- datos[, c("Altura", "Diametro", "Peso", "Poblacion", "Tallos_Ha", "Peso_Total", "TCH_Est")] #Solo para variables cuantitativas
pca <- PCA(variables, scale.unit = TRUE, graph = FALSE) #Escalar

#Gráfico de variables
fviz_pca_ind(pca, 
             geom.ind = "point",
             col.ind = datos$Tratamiento,   # variable categórica
             palette = "jco",
             addEllipses = TRUE,
             legend.title = "Grupo")

#Biplot
fviz_pca_biplot(pca, 
                col.ind = datos$Tratamiento,
                palette = "jco",
                addEllipses = TRUE,
                label = "var",
                col.var = "black")
#Gráfico de variables
fviz_pca_var(pca,
             col.var = "contrib",     # colorea por contribución al eje
             gradient.cols = c("blue", "blue", "red"),
             repel = TRUE)            # evita que se sobrepongan las etiquetas

#####################################--MLG con covariables--############################################

# Modelo GLM con covariables (ejemplo)
modelo_glm <- glm(Altura ~ Tratamiento + Diametro + Peso,
                  data = datos,
                  family = Gamma(link = "log"))

summary(modelo_glm)
Anova(modelo_glm)


# Residuos de Pearson
residuos <- residuals(modelo_glm, type = "pearson")
ajustados <- fitted(modelo_glm)

# Residuos vs ajustados
plot(ajustados, residuos,
     xlab = "Valores ajustados", ylab = "Residuos de Pearson",
     main = "Residuos vs Ajustados")
abline(h = 0, col = "red", lty = 2, lwd =2.5)

# Histograma de residuos
hist(residuos, main = "Histograma de residuos", xlab = "Residuos")

# Q-Q plot de residuos
qqnorm(residuos); qqline(residuos, col="red")


# Deviance / grados de libertad (debería ser ~1 si el modelo ajusta bien)
dispersion <- sum(residuos^2) / df.residual(modelo_glm)
dispersion

hoslem.test(datos$Altura, fitted(modelo_glm))  # similar al test Hosmer-Lemeshow

#DHARma
sim_res <- simulateResiduals(modelo_glm)
plot(sim_res)   # gráficos de dispersión, Q-Q y test de uniformidad
