paquetes <- c(
  "openxlsx", "fBasics", "psych", "modeest", "ggrepel", "GGally", 
  "mice", "corrplot", "readxl", "doebioresearch", "performance", "dplyr", 
  "ScottKnott", "agricolae", "car", "broom", "data.table", "emmeans", 
  "ggplot2", "tidyverse", "lattice", "nlme", "lme4", "lmerTest", "multcomp", 
  "rstatix", "ggpubr", "see", "MASS", "lsmeans", "scales", "lmtest", "multcompView", 
  "googlesheets4", "googledrive", "clipr", "FactoMineR", "factoextra", 
  "glmmTMB", "DHARMa", "MuMIn", "hnp", "effects", "sjstats", "ExpDes", "sf", "tmap", "terra",
  "RVAideMemoire", "RColorBrewer", "DiagrammeR", "esquisse", "dlookr")

# Verifica cuáles no están instalados
no_instalados <- paquetes[!(paquetes %in% installed.packages()[,"Package"])];no_instalados

# Instala los que faltan
if(length(no_instalados)) {
  install.packages(no_instalados)
} else {
  message("Todos los paquetes ya están instalados.")
}

# Carga todos los paquetes (opcional)
lapply(paquetes, library, character.only = TRUE)
#######################################--Carga y preparación de datos--#############################################
excel_sheets("Plagas del suelo San Jose Miramar.xlsx")
datos<- read_excel("Plagas del suelo San Jose Miramar.xlsx", sheet = 6)
attach(datos)
view(datos)
head(datos)
tail(datos)
names(datos)

# Estandarización del nombre de columnas
estandarizar_nombres_columnas <- function(df, excluir = c("Tratamiento", "Replica")) {
 
  nombres_actuales <- names(df)
  

  limpiar_nombre <- function(nombre) {
    
    if (nombre %in% excluir) {
      return(nombre)
    }
    
    
    nombre <- tolower(nombre)
    

    nombre <- gsub("%", "porc", nombre)
    nombre <- gsub("/", "_", nombre)
    nombre <- gsub("\\s+", "_", nombre)  
    nombre <- gsub("[^a-zA-Z0-9_-]", "", nombre)  
    nombre <- gsub("-+", "_", nombre)  
    nombre <- gsub("^-|-$", "", nombre)  
    
    return(nombre)
  }
  

  nombres_nuevos <- sapply(nombres_actuales, limpiar_nombre)
  
  
  names(df) <- nombres_nuevos
  
 
  cambios <- data.frame(
    Original = nombres_actuales,
    Estandarizado = nombres_nuevos,
    stringsAsFactors = FALSE
  )
  
  cat("=== RESUMEN DE CAMBIOS EN NOMBRES DE COLUMNAS ===\n")
  print(cambios)
  cat("\n")
  
  return(df)
}


cat("Aplicando estandarización de nombres de columnas al objeto 'datos'...\n")
datos <- estandarizar_nombres_columnas(datos)
cat("Estandarización completada. Los nombres estandarizados están en el objeto 'datos'.\n\n")


cat("Nombres de columnas en el objeto 'datos' después de la estandarización:\n")
print(names(datos))
cat("\n")


cat("Estructura del objeto 'datos' después de la estandarización:\n")
print(str(datos))
cat("\n")

attach(datos)
view(datos)
colnames(datos)


# Conversión de variables
names(datos)
# Variables numéricas
numericas <- c("ind_m2")  

# Factores
categoricas <- c("Tratamiento", "Replica")           

# Conversión a numéricas
for (col in numericas) {
  if (col %in% names(datos)) {
    datos[[col]] <- as.numeric(datos[[col]])
  } else {
    warning(paste("La columna", col, "no existe en datos."))
  }
}

# Conversión a factores
for (col in categoricas) {
  if (col %in% names(datos)) {
    datos[[col]] <- as.factor(datos[[col]])
  } else {
    warning(paste("La columna", col, "no existe en datos."))
  }
}

# Verificar
sapply(datos, class)
#######################################--Limpieza--#################################################################

create_report(datos)
diagnose(datos)
plot_na_pareto(datos) #grafica de datos faltantes: si no los hay, tira error


#------------------------------------------
# Análisis de datos atípicos
#------------------------------------------

names(datos)
# Errores de digitación

  # Variables:
variables_revisar <- c("total_larvas", "larvas_por_ha", "_porc_infestacion")   


for (var in variables_revisar) {
  
  if (var %in% names(datos)) {
    
    cat("\n\n-----------------------------\n")
    cat("Variable:", var, "\n")
    cat("-----------------------------\n")
    
    print(sort(datos[[var]], na.last = TRUE))
    
  } else {
    warning(paste("La variable", var, "no existe en 'datos'."))
  }
}



# Identificación con gráficos

vars_num <- c("ind_m2") 
var_group <- "Tratamiento"                        

# Histogramas
  # Según frecuencia
for (v in vars_num) {
  hist(
    datos[[v]],
    main = paste("Distribución de", v),
    xlab = v,
    col = "lightblue",
    breaks = 20
  )
}

  # Según densidad
for (v in vars_num) {
  
  dens <- density(datos[[v]], na.rm = TRUE)
  
  hist(
    datos[[v]],
    main = paste("Distribución de", v),
    xlab = v,
    col = "lightblue",
    breaks = 20,
    freq = FALSE   
  )
  
  lines(dens, lwd = 2, col = "red")
  
  abline(v = mean(datos[[v]], na.rm = TRUE), col = "darkgreen", lwd = 2, lty = 2)
}

# Boxplots
for (v in vars_num) {
  boxplot(
    datos[[v]] ~ datos[[var_group]],
    main = paste("Boxplot de", v, "por", var_group),
    xlab = var_group,
    ylab = v,
    col = "lightgreen"
  )
}


# Boxplots elegantes y ligeramente vivaces
for (v in vars_num) {
  

  colores <- c("#2E86AB", "#3CAEA3", "#F6D55C", "#ED553B", "#6A4C93", "#8E7CC3")
  n_grupos <- length(unique(datos[[var_group]]))
  colores <- colores[1:n_grupos]
  

  boxplot(
    datos[[v]] ~ datos[[var_group]],
    main = paste("Boxplot de", v, "por", var_group),
    xlab = var_group,
    ylab = v,
    col = colores,
    border = "black",
    notch = FALSE,
    las = 1,
    cex.main = 1.8,
    cex.lab = 1.5,
    cex.axis = 1.3,
    outline = TRUE
  )
  

  medias <- tapply(datos[[v]], datos[[var_group]], mean, na.rm = TRUE)
  

  points(1:length(medias), medias, col = "red", pch = 19, cex = 1.3)
}




# Boxplots con réplicas
vars_num <- c("ind_m2")
var_group <- "Tratamiento"
var_anidada <- "Replica" 

for (v in vars_num) {
  
  grafico_boxplot_final <- datos %>%
    ggplot(aes(x = as.factor(.data[[var_anidada]]), 
               y = .data[[v]], 
               fill = as.factor(.data[[var_anidada]]))) + 
    
    
    geom_boxplot(
      width = 0.9, 
      outlier.shape = 1, 
      outlier.size = 3,
      
      linewidth = 0.3 
    ) +
    
    
    facet_wrap(~ .data[[var_group]], 
               scales = "free_x", 
               ncol = 4) + 
    
    
    labs(
      title = paste("Boxplot de", v, "por Réplica dentro de cada Tratamiento"),
      x = "Réplica",
      y = v,
      fill = "Réplica"
    ) +
    
    
    theme_bw(base_size = 18) + 
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5, size = 22), 
      legend.position = "right",
      axis.title.x = element_blank(), 
      
      
      strip.text = element_text(size = 16, face = "bold"), 
      
      
      panel.spacing = unit(0.5, "lines") 
    ) +
    
    
    scale_fill_brewer(palette = "Dark2") 
  
  
  print(grafico_boxplot_final)
}


# Captura de valores de boxplot
outliers_list <- list()

for (v in vars_num) {
  bp <- boxplot(
    datos[[v]] ~ datos[[var_group]],
    plot = FALSE
  )
  outliers_list[[v]] <- bp$stats
}

outliers_list

# Datos atípicos por tratamiento
outliers_by_group <- list()

for (v in vars_num) {
  outliers_by_group[[v]] <- tapply(datos[[v]], datos[[var_group]], boxplot.stats)
}

outliers_by_group



# Eliminar datos atípicos
  # Método 1
names(datos)
numericas <- c("Total_Plantas", "Peso_Kg")
grupo <- "Tratamiento"   


for (v in numericas) {
  
  out <- boxplot(datos[[v]] ~ datos[[grupo]], plot = FALSE)$out
  
  datos[[v]][datos[[v]] %in% out] <- NA
}

colSums(is.na(datos[numericas]))

plot_na_pareto(datos) #grafica de datos faltantes: si no los hay, tira error



# Método 2: con el IQR

numericas <- c("Brix", "POL", "Pureza", "Humedad")  
grupo <- "Tratamiento"                               


for (v in numericas) {
  
  if (v %in% names(datos)) {
    
    Q1 <- quantile(datos[[v]], 0.25, na.rm = TRUE)
    Q3 <- quantile(datos[[v]], 0.75, na.rm = TRUE)
    IQR_val <- Q3 - Q1
    
    lower <- Q1 - 1.5 * IQR_val
    upper <- Q3 + 1.5 * IQR_val
    
    outliers <- datos[[v]] < lower | datos[[v]] > upper
    
    datos[[v]][outliers] <- NA # Reemplazar
    
    # Resumen
    cat("Variable:", v, "- Outliers reemplazados por NA:", sum(outliers), "\n")
  } else {
    warning(paste("La variable", v, "no existe en el dataset."))
  }
}

cat("\nResumen de NA por variable numérica:\n")
print(colSums(is.na(datos[numericas])))


#------------------------------------------
# Datos faltantes
#------------------------------------------

# Imputación con media

numericas <- c("Total_Plantas", "Peso_Kg")
colSums(is.na(datos[numericas]))

for (v in numericas) {
  datos[[v]][is.na(datos[[v]])] <- mean(datos[[v]], na.rm = TRUE)
}

colSums(is.na(datos[numericas]))
attach(datos)
view(datos)




###############################################--Análisis descriptivo--#######################################################
# Filtrar 

names(datos)
filtrar_por_tratamiento <- function(factor = "lote",
                                    incluir = NULL,
                                    excluir = "605") {
  
  if (!factor %in% names(datos)) {
    stop(paste("La columna", factor, "no existe en el objeto 'datos'."))
  }
  
  df <- datos
  
  if (!is.null(incluir)) {
    df <- df %>% dplyr::filter(.data[[factor]] %in% incluir)
  }
  
  if (!is.null(excluir)) {
    df <- df %>% dplyr::filter(!(.data[[factor]] %in% excluir))
  }
  
  assign("datos", df, envir = .GlobalEnv)
}

filtrar_por_tratamiento() # Llamada a función
view(datos)

##############################################################################
attach(datos)
# Medidas de resumen
names(datos)

factores <- c("Tratamiento")

estadisticas_por_variable <- list(
  ind_m2 = "media",
  gc___m2 = "media",
  ga___m2 = "media",
  c__m2 = "media",
  ch___m2 = "media"
)

calc_stat <- function(x, stat) {
  if(length(x) == 0 || all(is.na(x))) return(NA)
  
  n <- sum(!is.na(x))
  m <- mean(x, na.rm = TRUE)
  s <- sd(x, na.rm = TRUE)
  
  switch(stat,
         "media"   = m,
         "total"   = sum(x, na.rm = TRUE),
         "sd"      = s,
         "var"     = var(x, na.rm = TRUE),
         "CV"      = if(m != 0) (s/m)*100 else NA,
         "min"     = min(x, na.rm = TRUE),
         "max"     = max(x, na.rm = TRUE),
         "mediana" = median(x, na.rm = TRUE),
         "SE"      = s / sqrt(n),
         "LS"      = m + (s / sqrt(n)),
         "LI"      = m - (s / sqrt(n)),
         stop("Estadística no reconocida: ", stat)
  )
}

variables_existentes <- names(estadisticas_por_variable)[names(estadisticas_por_variable) %in% names(datos)]

if(length(variables_existentes) == 0) {
  stop("Error: Ninguna de las variables especificadas existe en los datos. ",
       "Variables especificadas: ", paste(names(estadisticas_por_variable), collapse = ", "),
       "\nVariables disponibles: ", paste(names(datos), collapse = ", "))
}


nombres_columnas <- character(length(variables_existentes))
for(i in seq_along(variables_existentes)) {
  var <- variables_existentes[i]
  stat <- estadisticas_por_variable[[var]]
  nombres_columnas[i] <- paste0(var, "_", stat)
}

resumen <- datos %>%
  group_by(across(all_of(factores))) %>%
  summarise(
    across(
      all_of(variables_existentes),
      ~ {
        var_name <- cur_column()
        calc_stat(.x, estadisticas_por_variable[[var_name]])
      }
    ),
    .groups = "drop"
  )


names(resumen)[(length(factores) + 1):ncol(resumen)] <- nombres_columnas


print("Resumen estadístico:")
print(resumen)                      # Mostrar resultados


cat("\nVariables procesadas:", paste(variables_existentes, collapse = ", "), "\n")
cat("Factores de agrupación:", paste(factores, collapse = ", "), "\n")


################################################################
# Tablas de doble entrada (contingencia)
names(datos)

fila <- "no. Liberacion"
columna <- "Tratamiento" 
variable <- "Porcentaje de parasitoidismo"
estadistica <- "media"  # Opciones: "media", "mediana", "suma", "min", "max", 
# "sd", "cv", "ee", "ls", "li"


tabla <- datos %>%
  group_by(across(all_of(c(fila, columna)))) %>%
  summarise(Valor = case_when(
    estadistica == "media" ~ mean(.data[[variable]], na.rm = TRUE),
    estadistica == "mediana" ~ median(.data[[variable]], na.rm = TRUE),
    estadistica == "suma" ~ sum(.data[[variable]], na.rm = TRUE),
    estadistica == "min" ~ min(.data[[variable]], na.rm = TRUE),
    estadistica == "max" ~ max(.data[[variable]], na.rm = TRUE),
    estadistica == "sd" ~ sd(.data[[variable]], na.rm = TRUE),
    estadistica == "cv" ~ (sd(.data[[variable]], na.rm = TRUE) / mean(.data[[variable]], na.rm = TRUE)) * 100,
    estadistica == "ee" ~ sd(.data[[variable]], na.rm = TRUE) / sqrt(length(na.omit(.data[[variable]]))),
    estadistica == "ls" ~ mean(.data[[variable]], na.rm = TRUE) + (sd(.data[[variable]], na.rm = TRUE) / sqrt(length(na.omit(.data[[variable]])))),
    estadistica == "li" ~ mean(.data[[variable]], na.rm = TRUE) - (sd(.data[[variable]], na.rm = TRUE) / sqrt(length(na.omit(.data[[variable]]))))
  ), .groups = 'drop') %>%
  pivot_wider(
    names_from = all_of(columna), 
    values_from = Valor
  )

print(tabla)
############################################################
# Tabla con IC y otras medidas de resumen
names(datos)

variables_numericas <- c("ind_m2")       
factores <- c("Tratamiento")                       
medidas_estadisticas <- c("media", "sd", "se", "li", "ls", "max", "min")


calcular_estadisticas <- function(datos, variable, factor_grupo, medidas) {
  tryCatch({
    if (!variable %in% names(datos)) stop(paste("Variable", variable, "no encontrada"))
    
    datos_temp <- datos
    datos_temp[[variable]] <- as.numeric(datos_temp[[variable]])
    
    resumen <- datos_temp %>%
      group_by(across(all_of(factor_grupo))) %>%
      summarise(
        n = n(),
        media = mean(.data[[variable]], na.rm = TRUE),
        total = sum(.data[[variable]], na.rm = TRUE),
        sd = sd(.data[[variable]], na.rm = TRUE),
        max = max(.data[[variable]], na.rm = TRUE),
        min = min(.data[[variable]], na.rm = TRUE),
        .groups = "drop"
      ) %>%
      mutate(
        se = sd / sqrt(n),
        li = media - 1.96 * se,
        ls = media + 1.96 * se,
        cv = ifelse(media != 0, (sd / media) * 100, NA)
      ) %>%
      mutate(across(where(is.numeric), ~ round(.x, 4)))
    
    
    columnas_disponibles <- c(factor_grupo, medidas)
    columnas_disponibles <- columnas_disponibles[columnas_disponibles %in% names(resumen)]
    
    resumen <- resumen %>%
      select(all_of(columnas_disponibles)) %>%
      mutate(Variable = variable) %>%
      select(Variable, everything())
    
    return(resumen)
  }, error = function(e) {
    warning(paste("Error procesando variable", variable, ":", e$message))
    return(NULL)
  })
}


verificar_datos <- function(datos) {
  cat("Verificando estructura de datos...\n")
  cat("Dimensiones:", dim(datos)[1], "filas x", dim(datos)[2], "columnas\n")
  cat("Clases de variables:\n")
  print(sapply(datos, class))
  cat("\n")
}

verificar_datos(datos)


variables_existentes <- variables_numericas[variables_numericas %in% names(datos)]
factores_existentes <- factores[factores %in% names(datos)]
medidas_disponibles <- c("media", "total", "sd", "se", "li", "ls", "cv", "n", "max", "min")
medidas_solicitadas <- medidas_estadisticas[medidas_estadisticas %in% medidas_disponibles]


if(length(variables_existentes) > 0 && length(factores_existentes) > 0 && length(medidas_solicitadas) > 0) {
  
  cuadros_individuales <- list()
  
  for(variable_actual in variables_existentes) {
    cat("Procesando variable:", variable_actual, "...\n")
    resultado <- calcular_estadisticas(datos, variable_actual, factores_existentes, medidas_solicitadas)
    if(!is.null(resultado)) {
      cuadros_individuales[[variable_actual]] <- resultado
      cat("✅ Cuadro generado para", variable_actual, "\n")
      print(resultado)
      cat("\n")
    }
  }
  
  if(length(cuadros_individuales) > 0) {
    cuadro_general <- bind_rows(cuadros_individuales)
    assign("cuadro_general_estadisticas", cuadro_general, envir = .GlobalEnv)
    
    cat("Resumen final generado con todas las variables.\n")
  }
  
} else {
  cat("Configuración inválida. Verifica que las variables y factores existan y que las medidas solicitadas sean válidas.\n")
}


######################################################
# Gráficos

# Gráfico de barras
names(datos)
numericas <- c("porc_infestacion")
factor_group <- "Tratamiento"

resumen <- datos %>%
  group_by(across(all_of(factor_group))) %>%
  summarise(across(all_of(numericas), mean, na.rm = TRUE), .groups = "drop")

for (v in numericas) {
  resumen[[paste0(v, "_label")]] <- sprintf("%.2f", resumen[[v]])
}

for (v in numericas) {
  label_col <- paste0(v, "_label")
  
  p <- ggplot(resumen, aes_string(x = factor_group, y = v)) +
    geom_bar(stat = "identity", fill = "lightblue", color = "black", width = 0.6) +  # solo delineado
    geom_text(aes_string(label = label_col), vjust = -0.5, color = "black") +
    labs(title = paste("Gráfico de barras - medias de", v),
         x = factor_group,
         y = v) +
    theme_minimal(base_size = 14)
  
  print(p)
}


# Gráfico de líneas y puntos
names(datos)
numericas <- c("porc_infestacion", "total_larvas")  
factor_group <- "Tratamiento"                     

resumen <- datos %>%
  group_by(across(all_of(factor_group))) %>%
  summarise(across(all_of(numericas), mean, na.rm = TRUE), .groups = "drop")

for (v in numericas) {
  resumen[[paste0(v, "_label")]] <- sprintf("%.2f", resumen[[v]])
}

for (v in numericas) {
  
  label_col <- paste0(v, "_label")
  
  p <- ggplot(resumen, aes_string(x = factor_group, y = v, group = 1)) +
    
    geom_line(color = "#2C3E50", size = 1.2) +
    
    geom_point(color = "#E74C3C", size = 3) +
    
    geom_text(aes_string(label = label_col), vjust = -1, color = "#34495E", size = 4) +
    
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.title = element_text(face = "bold"),
      panel.grid.major = element_line(color = "grey80"),
      panel.grid.minor = element_blank()
    ) +
    labs(title = paste("Promedio de", v, "por", factor_group),
         x = factor_group,
         y = v)
  
  print(p)
}



##################################################
# Gráficos de barras con factores de partición
names(datos)


config <- list(
  datos = datos,                   
  variable_y = "porc_infestacion", 
  factor_principal = "Tratamiento", 
  factores_adicionales = c("muestreo"),
  orden_niveles = list(            
    muestreo = c("Pre_Muestreo", "1er_Muestreo", "2do_Muestreo")
  ),
  tipo_resumen = "media"           # "media" o "total"
)


graficos_barras_flexibles <- function(config) {
  library(dplyr)
  library(ggplot2)
  
  df <- config$datos
  
  todos_factores <- c(config$factor_principal, config$factores_adicionales)
  for(fac in todos_factores) {
    if(!is.null(config$orden_niveles[[fac]])) {
      df[[fac]] <- factor(df[[fac]], levels = config$orden_niveles[[fac]])
    }
  }
  
  resultados <- list()
  

  if(length(config$factores_adicionales) == 0) config$factores_adicionales <- ""
  
  for(factor_actual in config$factores_adicionales) {
    

    agrupacion <- if(factor_actual != "") c(config$factor_principal, factor_actual) else config$factor_principal
    

    if(config$tipo_resumen == "media") {
      df_resumen <- df %>%
        group_by_at(agrupacion) %>%
        summarise(
          valor = mean(get(config$variable_y), na.rm=TRUE),
          se = sd(get(config$variable_y), na.rm=TRUE)/sqrt(n()),
          .groups="drop"
        )
    } else if(config$tipo_resumen == "total") {
      df_resumen <- df %>%
        group_by_at(agrupacion) %>%
        summarise(
          valor = sum(get(config$variable_y), na.rm=TRUE),
          se = NA, # no tiene sentido error estándar para total
          .groups="drop"
        )
    } else {
      stop("tipo_resumen debe ser 'media' o 'total'")
    }
    
  
    if(factor_actual != "") {
      g <- ggplot(df_resumen, aes_string(x = config$factor_principal,
                                         y = "valor",
                                         fill = factor_actual))
    } else {
      g <- ggplot(df_resumen, aes_string(x = config$factor_principal,
                                         y = "valor"))
    }
    
    g <- g +
      geom_bar(stat="identity", position=position_dodge(0.8), width=0.7, alpha=0.8) +
      # Solo agregar error si se calcula
      {if(config$tipo_resumen == "media") geom_errorbar(aes(ymin = valor - se, ymax = valor + se),
                                                        position=position_dodge(0.8), width=0.2, size=0.5) } +
      theme_minimal(base_size = 13) +
      theme(
        plot.title = element_text(face="bold", size=14, hjust=0.5),
        axis.title = element_text(face="bold", size=12),
        legend.title = element_text(face="bold")
      ) +
      labs(
        x = config$factor_principal,
        y = if(config$tipo_resumen=="media") paste("Media de", config$variable_y) else paste("Total de", config$variable_y),
        fill = factor_actual,
        title = paste("Gráfico de barras de", config$variable_y)
      )
    
    print(g)
    resultados[[factor_actual]] <- g
  }
  
  return(resultados)
}

graficos <- graficos_barras_flexibles(config) # Gráficar


##################################################################
# Barras de error exploratorias
names(datos)

config <- list(
  datos = datos,                    
  variable_y = "ind_m2",  
  factor = "Tratamiento",           
  factor_adicional = "",            
  orden_niveles = list(             
    Tratamiento = c(),
    muestreo = c()
  ),
  tipo_error = "IC",                # "SE", "SD" o "IC"
  mostrar_linea = T,            # TRUE = dibuja línea entre medias, FALSE = solo puntos
  color_punto = "red",             # color de los puntos si no hay factor adicional
  color_error = "black"             # color de las barras de error si no hay factor adicional
)


graficos_puntos_error <- function(config) {
  library(dplyr)
  library(ggplot2)
  
  df <- config$datos
  
 
  for(fac in c(config$factor, config$factor_adicional)) {
    if(!is.null(fac) && fac != "" && !is.null(config$orden_niveles[[fac]])) {
      df[[fac]] <- factor(df[[fac]], levels = config$orden_niveles[[fac]])
    }
  }
  
  
  if(!is.null(config$factor_adicional) && config$factor_adicional != "") {
    agrupacion <- c(config$factor, config$factor_adicional)
    aes_map <- aes_string(
      x = config$factor_adicional,
      y = "media",
      group = config$factor,
      color = config$factor
    )
    color_point <- NULL   # color automático según factor
    color_error <- NULL   # color automático según factor
  } else {
    agrupacion <- config$factor
    aes_map <- aes_string(
      x = config$factor,
      y = "media",
      group = 1
    )
    color_point <- config$color_punto
    color_error <- config$color_error
  }
  

  df_resumen <- df %>%
    group_by_at(agrupacion) %>%
    summarise(
      media = mean(get(config$variable_y), na.rm=TRUE),
      sd_val = sd(get(config$variable_y), na.rm=TRUE),
      n = n(),
      .groups="drop"
    ) %>%
    mutate(
      error = case_when(
        config$tipo_error == "SE" ~ sd_val/sqrt(n),
        config$tipo_error == "SD" ~ sd_val,
        config$tipo_error == "IC" ~ 1.96*sd_val/sqrt(n),
        TRUE ~ NA_real_
      )
    )
  
  # Crear gráfico
  g <- ggplot(df_resumen, aes_map)
  
  # Línea opcional
  if(isTRUE(config$mostrar_linea)) {
    g <- g + geom_line(linewidth = 1, color = "black") # color_point para mismo color de pto
  }
  
  # Puntos
  g <- g + geom_point(size = 4, color = color_point)
  
  # Barras de error
  g <- g + geom_errorbar(aes(ymin = media - error, ymax = media + error),
                         width = 0.2, size = 0.6, color = color_error)
  
  # Tema profesional
  g <- g +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face="bold", size=14, hjust=0.5),
      axis.title = element_text(face="bold", size=12),
      legend.title = element_text(face="bold")
    ) +
    labs(
      x = if(!is.null(config$factor_adicional) && config$factor_adicional != "") config$factor_adicional else config$factor,
      y = paste("Media de", config$variable_y),
      color = if(!is.null(config$factor_adicional) && config$factor_adicional != "") config$factor else NULL,
      title = paste("Gráfico de puntos con error:", config$variable_y)
    )
  
  print(g)
  return(g)
}

grafico <- graficos_puntos_error(config)


#################################################################

#                        Curvas de maduración
################################################################

names(datos)

library(dplyr)
library(ggplot2)
library(ggpubr)
library(tidyr)

# Calcular medias de pol según dda y Tratamiento y redondear a 2 decimales
datos_medias <- datos %>%
  group_by(Tratamiento, dda) %>%
  summarise(pol_media = round(mean(pol, na.rm = TRUE), 2)) %>%
  ungroup()

# Gráfico con estética mejorada
grafico <- ggplot(datos_medias, aes(x = dda, y = pol_media, color = Tratamiento)) +
  geom_line(size = 1.5) +
  geom_point(size = 3) +
  labs(
    x = "Días después de la aplicación (DDA)",
    y = "Pol (%)",
    color = "Tratamiento",
    title = "Curva de maduración por Tratamiento"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(linetype = "dashed", color = "grey80"),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    axis.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12)
  )

# Crear tabla resumen para mostrar debajo del gráfico
tabla_resumen <- datos_medias %>%
  pivot_wider(names_from = Tratamiento, values_from = pol_media)

tabla_grob <- ggpubr::ggtexttable(tabla_resumen, 
                                  rows = NULL, 
                                  theme = ttheme(base_size = 12))

# Combinar gráfico y tabla
ggpubr::ggarrange(grafico, tabla_grob, 
                  ncol = 1, nrow = 2, 
                  heights = c(3, 1))


##################################################################
#                  Gráfico de curvas en general
##################################################################

names(datos)

library(dplyr)
library(ggplot2)
library(ggpubr)
library(tidyr)

# Calcular medias de pol según dda y Tratamiento y redondear a 2 decimales
datos_medias <- datos %>%
  group_by(Tratamiento, numero_de_muestra) %>%
  summarise(pol_media = round(mean(ind_m2, na.rm = TRUE), 2)) %>%
  ungroup()

# Gráfico con estética mejorada
grafico <- ggplot(datos_medias, aes(x = numero_de_muestra, y = pol_media, color = Tratamiento)) +
  geom_line(size = 1.5) +
  geom_point(size = 3) +
  labs(
    x = "Número de muestra",
    y = "Individuos/m2",
    color = "Tratamiento",
    title = "Curva de densidad poblacional"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(linetype = "dashed", color = "grey80"),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    axis.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12)
  )

# Crear tabla resumen para mostrar debajo del gráfico
tabla_resumen <- datos_medias %>%
  pivot_wider(names_from = Tratamiento, values_from = pol_media)

tabla_grob <- ggpubr::ggtexttable(tabla_resumen, 
                                  rows = NULL, 
                                  theme = ttheme(base_size = 12))

# Combinar gráfico y tabla
ggpubr::ggarrange(grafico, tabla_grob, 
                  ncol = 1, nrow = 2, 
                  heights = c(3, 1))



###############################################--ANDEVA--#########################################################
# Pegar el bucle según corresponda el diseño experimental y arreglo factorial 

names(datos)


alpha <- 0.15  

tratamiento <- "Tratamiento"
respuestas <- c("ind_m2")

for (var in respuestas) {
  formula <- as.formula(paste0("`", var, "` ~ factor(", tratamiento, ") + factor(Replica)"))
  modelo <- aov(formula, data = datos)
  
  cat("\n====================================\n")
  cat("Variable:", var, "\n")
  cat("====================================\n")
  
  print(anova(modelo))   # uso anova() en lugar de summary() para que coincida con el manual
}


# Verificación de supuestos
for (var in respuestas) {
  formula <- as.formula(paste0("`", var, "` ~ factor(", tratamiento, ") + factor(Replica)"))
  modelo <- aov(formula, data = datos)
  
  cat("\n====================================\n")
  cat("Variable:", var, "\n")
  cat("====================================\n")
  
  cat("\n--- Verificación de supuestos ---\n")
  
  # 1. QQ-plot
  qqPlot(modelo$residuals, main=paste("QQ-plot:", var), col="red", lwd=2, pch=16)
  
  # 2. Residuos vs Ajustados
  plot(modelo$fitted.values, modelo$residuals,
       main=paste("Residuos vs Ajustados:", var),
       xlab="Valores Ajustados", ylab="Residuos", pch=16, col="blue")
  abline(h=0, col="red", lwd=2)
  
  # Shapiro-Wilk
  if(length(unique(modelo$residuals)) > 1){
    SW <- shapiro.test(modelo$residuals)
    cat("\nShapiro-Wilk para", var, ":\n")
    print(SW)
  } else {
    cat("\nShapiro-Wilk no se puede calcular: todos los residuos son idénticos.\n")
  }
  
  # Bartlett y Levene con manejo de errores
  if(length(unique(datos[[var]])) > 1){
    
    # Verificar que todos los grupos tengan al menos 2 observaciones para Bartlett
    conteo_por_grupo <- table(datos[[tratamiento]])
    grupos_validos <- all(conteo_por_grupo >= 2)
    
    if(grupos_validos){
      cat("\nPrueba de Bartlett para", var, ":\n")
      bartlett_result <- tryCatch({
        bartlett.test(as.formula(paste0("`", var, "` ~ factor(", tratamiento, ")")), data=datos)
      }, error = function(e) {
        return(paste("Error en Bartlett:", e$message))
      })
      print(bartlett_result)
    } else {
      cat("\nPrueba de Bartlett no se puede calcular: algunos tratamientos tienen menos de 2 observaciones.\n")
    }
    
    # Levene es más robusto, lo intentamos igual
    cat("\nPrueba de Levene para", var, ":\n")
    levene_result <- tryCatch({
      leveneTest(as.formula(paste0("`", var, "` ~ factor(", tratamiento, ")")), 
                 data=datos, center="median")
    }, error = function(e) {
      return(paste("Error en Levene:", e$message))
    })
    print(levene_result)
    
  } else {
    cat("Bartlett y Levene no se pueden calcular: variable constante.\n")
  }
  
  cat("\n------------------------------------\n")
}


# Prueba Múltiple de Medias (PMM):

for (var in respuestas) {
  
  # Crear un nombre seguro para la variable
  nombre_var <- paste0("var_", gsub("[^[:alnum:]_]", "_", var))
  
  # Ignorar nombres inválidos
  if(grepl("^var_[_]*$", nombre_var)){
    cat("\nVariable", var, "omitida: nombre no válido.\n")
    next
  }
  
  # Crear dataframe temporal y renombrar variable
  datos_temp <- datos
  names(datos_temp)[names(datos_temp) == var] <- nombre_var
  
  # Asegurar que Tratamiento y Replica sean factores
  datos_temp$Tratamiento <- factor(datos_temp$Tratamiento)
  datos_temp$Replica <- factor(datos_temp$Replica)
  
  # Modelo ANDEVA
  formula <- as.formula(paste0("`", nombre_var, "` ~ Tratamiento + Replica"))
  modelo <- aov(formula, data = datos_temp)
  
  cat("\n====================================\n")
  cat("Variable:", var, "\n")
  cat("====================================\n")
  
  # Verificar que hay más de un valor y más de un nivel con datos
  niveles_con_datos <- sum(tapply(datos_temp[[nombre_var]], datos_temp$Tratamiento,
                                  function(x) length(unique(x)) > 0))
  
  if(length(unique(datos_temp[[nombre_var]])) > 1 & niveles_con_datos > 1){
    
    # -------------------------
    # Tukey HSD
    # -------------------------
    cat("\n--- Tukey HSD (alpha =", alpha, ") ---\n")
    print(HSD.test(modelo, trt = "Tratamiento", alpha = alpha, console = TRUE))
    
    # -------------------------
    # TukeyHSD (stats) - BLOQUE AGREGADO
    # -------------------------
    cat("\n--- TukeyHSD (función base R) ---\n")
    tukey_base <- TukeyHSD(modelo, which = "Tratamiento", conf.level = 1 - alpha)
    print(tukey_base)
    
    # -------------------------
    # Scott-Knott
    # -------------------------
    cat("\n--- Scott-Knott (alpha =", alpha, ") ---\n")
    sk <- SK(modelo, which = "Tratamiento", dispersion = "se", sig.level = alpha)
    print(summary(sk))
    
  } else {
    cat("\nPMM no se puede calcular: variable constante o menos de 2 niveles de tratamiento con datos.\n")
  }
  
  cat("\n------------------------------------\n")
}


# Barras de error:

alpha <- 0.15   


for (var in respuestas) {
  
  datos_temp <- datos
  names(datos_temp)[names(datos_temp) == var] <- "valor"
  
  datos_temp$Tratamiento <- factor(datos_temp$Tratamiento)
  datos_temp$Replica <- factor(datos_temp$Replica)
  
  modelo <- aov(valor ~ Tratamiento + Replica, data = datos_temp)
  
  
  tukey <- HSD.test(modelo, "Tratamiento", group = TRUE, alpha = alpha)
  
  letras <- tukey$groups %>%
    mutate(Tratamiento = rownames(tukey$groups)) %>%
    select(Tratamiento, letra = groups)
  
  
  resumen <- datos_temp %>%
    group_by(Tratamiento) %>%
    summarise(
      media = mean(valor, na.rm = TRUE),
      sd = sd(valor, na.rm = TRUE),
      n = n(),
      se = sd / sqrt(n),
      
      t_value = qt(1 - alpha/2, df = n - 1),
      
      IC_inf = media - t_value * se,
      IC_sup = media + t_value * se,
      .groups = "drop"
    ) %>%
    left_join(letras, by = "Tratamiento") %>%
    arrange(media) %>%
    mutate(Trat_ordenado = factor(Tratamiento, levels = Tratamiento))
  
  colores <- "steelblue"
  
  print(
    ggplot(resumen, aes(x = Trat_ordenado, y = media)) +
      geom_point(size = 3, color = colores) +
      geom_errorbar(aes(ymin = IC_inf, ymax = IC_sup), width = 0.15) +
      geom_text(aes(label = letra, y = IC_sup + 0.05 * max(media)),
                size = 7, vjust = 0) +
      labs(title = paste("Medias ± IC (1 - α) con letras Tukey -", var),
           subtitle = paste("α =", alpha),
           y = var, x = "Tratamiento") +
      theme_minimal(base_size = 17) +
      theme(plot.title = element_text(hjust = 0.5))
  )
}




###############################--MLM--###############################################################
colnames(datos)

respuestas <- c("tch")  # agregar todas tus variables

#-----------------------------
# Definir efectos
#-----------------------------
efectos_fijos <- c("Tratamiento")
efectos_aleatorios <- c("(1 | Replica)")

# Convertir factores
factores <- c("Tratamiento", "Replica")
for(f in factores){
  if(f %in% colnames(datos)) datos[[f]] <- factor(datos[[f]])
}

#-----------------------------
# Bucle completo para todas las variables
#-----------------------------
for(var in respuestas){
  cat("\n====================================\n")
  cat("Variable:", var, "\n")
  cat("====================================\n")
  
  # Construir fórmula
  fixed_str <- paste(efectos_fijos, collapse = " + ")
  random_str <- paste(efectos_aleatorios, collapse = " + ")
  formula <- as.formula(paste0(var, " ~ ", fixed_str, " + ", random_str))
  
  # Ajustar modelo
  modelo <- lmer(formula, data = datos, REML = TRUE)
  
  # Resultados
  print(summary(modelo))
  print(anova(modelo))
  
  #-----------------------------
  # Verificación de supuestos
  #-----------------------------
  
  # Simulación de residuos DHARMa
  sim_res <- simulateResiduals(modelo)
  
  # Boxplot por factor, evitando problema de longitud
  trat <- model.frame(modelo)$Tratamiento
  plotResiduals(sim_res, form = trat)
  
  # Gráficos generales de DHARMa
  plot(sim_res)
  
  # Shapiro-Wilk
  cat("\nShapiro-Wilk de residuos simulados:\n")
  print(shapiro.test(residuals(sim_res)))
  
  # Residuos vs ajustados
  fitted_vals <- fitted(modelo)
  resids <- resid(modelo)
  p1 <- ggplot(data.frame(Fitted=fitted_vals, Resid=resids), aes(x=Fitted, y=Resid)) +
    geom_point() + 
    geom_hline(yintercept=0, linetype="dashed", color="red") +
    labs(title=paste("Residuos vs Ajustados:", var))
  print(p1)
  
  # Residuos vs orden
  p2 <- ggplot(data.frame(Order=1:length(resids), Resid=resids), aes(x=Order, y=Resid)) +
    geom_point() + 
    geom_hline(yintercept=0, linetype="dashed", color="red") +
    labs(title=paste("Residuos vs Orden:", var))
  print(p2)
  
  # ACF de residuos
  cat("\nACF de residuos:\n")
  acf(resids, main=paste("ACF de residuos:", var))
}



# Prueba de Tukey
respuestas <- c("tch")
nivel_significancia <- 0.15  # 15%

#-----------------------------
# Tukey por pares con nivel personalizado
#-----------------------------
cat("\n=== Tukey HSD (α =", nivel_significancia, ") ===\n")

for(var in respuestas){
  cat("\n", strrep("=", 50))
  cat("\nVariable:", var, "\n")
  cat(strrep("=", 50), "\n")
  
  modelo <- lmer(paste(var, "~ Tratamiento + (1 | Replica)"), data = datos)
  
  # Tukey con nivel personalizado
  emm <- emmeans(modelo, ~ Tratamiento)
  contrastes <- pairs(emm, adjust = "tukey")
  
  cat("Comparaciones por pares (Tukey):\n")
  print(summary(contrastes, level = 1 - nivel_significancia))
}

#-----------------------------
# Gráficos con letras de Tukey (15%)
#-----------------------------
for(var in respuestas){
  cat("\n", strrep("=", 50))
  cat("\nVariable:", var, "\n")
  cat(strrep("=", 50), "\n")
  
  modelo <- lmer(paste(var, "~ Tratamiento + (1 | Replica)"), data = datos)
  
  # Letras de Tukey con alpha = 0.15
  letras <- cld(emmeans(modelo, ~ Tratamiento), 
                Letters = letters, 
                adjust = "tukey", 
                alpha = nivel_significancia)
  
  resumen <- as.data.frame(letras)
  resumen <- resumen[order(-resumen$emmean), ]
  
  print(resumen)
  
  # Gráfico principal
  p <- ggplot(resumen, aes(x = reorder(Tratamiento, -emmean), y = emmean)) +
    geom_col(fill = "lightblue", alpha = 0.7) +
    geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), 
                  width = 0.2, color = "black", linewidth = 0.8) +
    geom_text(aes(label = .group, y = upper.CL * 1.08), 
              size = 5, fontface = "bold") +
    labs(title = paste(var, "- α =", nivel_significancia),
         x = "Tratamiento",
         y = "Media ajustada",
         caption = paste("Letras diferentes: p <", nivel_significancia)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
}

#-----------------------------
# Versión con puntos (alternativa)
#-----------------------------
for(var in respuestas){
  modelo <- lmer(paste(var, "~ Tratamiento + (1 | Replica)"), data = datos)
  
  letras <- cld(emmeans(modelo, ~ Tratamiento), 
                Letters = letters, 
                adjust = "tukey", 
                alpha = nivel_significancia)
  
  resumen <- as.data.frame(letras)
  resumen <- resumen[order(-resumen$emmean), ]
  
  p_puntos <- ggplot(resumen, aes(x = reorder(Tratamiento, -emmean), y = emmean)) +
    geom_point(size = 3, color = "darkblue") +
    geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), 
                  width = 0.15, color = "red", linewidth = 1) +
    geom_text(aes(label = .group, y = upper.CL * 1.1), 
              size = 4, fontface = "bold", color = "darkgreen") +
    labs(title = paste(var, "- α =", nivel_significancia),
         x = "Tratamiento", 
         y = var) +
    theme_classic()
  
  print(p_puntos)
}

#############################################-MLG-##################################################

############## Diagnóstico inicial:
names(datos)

check_overdispersion <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type = "pearson")
  dispersion <- sum(rp^2) / rdf
  return(dispersion)
}


is_count_variable <- function(x) {
  return(is.numeric(x) && all(x == floor(x), na.rm = TRUE) && all(x >= 0, na.rm = TRUE))
}


is_proportion_variable <- function(x) {
  return(is.numeric(x) &&
           all(x >= 0, na.rm = TRUE) &&
           all(x <= 1 | x <= 100, na.rm = TRUE))
}



diagnose_variables <- function(df) {
  
  for (var in names(df)) {
    x <- df[[var]]
    
 
    if (!is.numeric(x)) next
    
    cat("\n=============================\n")
    cat("Variable:", var, "\n")
    cat("=============================\n")
    
 
    
    if (is_count_variable(x)) {
      cat("Tipo de variable detectado: CONTEO\n")
      
      media <- mean(x, na.rm = TRUE)
      varianza <- var(x, na.rm = TRUE)
      
      cat("Media:", media, "\n")
      cat("Varianza:", varianza, "\n\n")
      

      if (varianza > media * 1.5) {
        cat("→ Evidencia de SOBREDISPERSIÓN (Var > Media).\n")
      } else {
        cat("→ No hay evidencia fuerte de sobredispersión por media-varianza.\n")
      }
      

      try({
        m_pois <- glm(x ~ 1, family = poisson)
        disp <- check_overdispersion(m_pois)
        cat("\nFactor de dispersión (Poisson):", disp, "\n")
        
        if (disp > 1.5) {
          cat("→ El modelo Poisson está sobredisperso.\n")
          cat("Sugerencia: Binomial Negativa o Quasi-Poisson.\n")
        } else {
          cat("→ Poisson parece adecuado.\n")
        }
      }, silent = TRUE)
      
      next
    }
    
    
    if (is_proportion_variable(x)) {
      cat("Tipo de variable detectado: PROPORCIÓN / PORCENTAJE\n")
      
  
      if (max(x, na.rm = TRUE) > 1) {
        xp <- x / 100
        cat("→ Detectado porcentaje. Convertido automáticamente a proporción 0–1.\n")
      } else {
        xp <- x
      }
      

      if (any(xp == 0 | xp == 1, na.rm = TRUE)) {
        cat("→ La variable contiene valores 0 o 1 exactos.\n")
        cat("Sugerencia: Modelo Beta inflado (Zero-One Inflated Beta) o Quasi-binomial.\n")
      } else {
        cat("→ No hay valores extremos exactos.\n")
        cat("Sugerencia: Beta Regression es adecuada.\n")
      }
      

      try({
        m_qb <- glm(xp ~ 1, family = quasibinomial)
        disp <- check_overdispersion(m_qb)
        
        cat("\nFactor de dispersión (Quasi-binomial):", disp, "\n")
        
        if (disp > 1.5) {
          cat("→ Sobredispersión importante.\n")
          cat("Recomendación: Quasi-binomial o Beta regression.\n")
        } else {
          cat("→ Variabilidad moderada, modelos binomiales pueden funcionar.\n")
        }
      }, silent = TRUE)
      
      next
    }
    
    
    cat("Tipo de variable: Continua (no conteo, no proporción)\n")
    cat("→ No se analiza distribución especial.\n")
  }
}


diagnose_variables(datos) # resultados de diagnóstico 


############# Variables de conteo ########################

# Distribución binomial negativa y quassi poisson

names(datos)
attach(datos)
view(datos)

factores <- c("Tratamiento", "Replica")


variables_respuesta <- c("ind_m2")


terminos_modelo <- c("Tratamiento", "Replica")


familias_modelos <- c("binomial_negativa")  # binomial_negativa, quasipoisson


if (!require(MASS)) install.packages("MASS"); library(MASS)
if (!require(car)) install.packages("car"); library(car)
if (!require(dplyr)) install.packages("dplyr"); library(dplyr)
if (!require(purrr)) install.packages("purrr"); library(purrr)


crear_formula <- function(respuesta, terminos) {
  formula_str <- paste0(respuesta, " ~ ", paste(terminos, collapse = " + "))
  as.formula(formula_str)
}


ajustar_modelo <- function(formula, datos, familia) {
  tryCatch({
    switch(familia,
           "binomial_negativa" = glm.nb(formula, data = datos),
           "quasipoisson" = glm(formula, data = datos, family = quasipoisson()),
           stop("Familia no reconocida: ", familia)
    )
  }, error = function(e) {
    warning("Error ajustando modelo: ", e$message)
    return(NULL)
  })
}


extraer_anova <- function(modelo, familia) {
  if (is.null(modelo)) return(NULL)
  
  tryCatch({

    anova_result <- Anova(modelo, type = "II", test = "LR")
    anova_df <- as.data.frame(anova_result)
    anova_df$Termino <- rownames(anova_df)
    rownames(anova_df) <- NULL
    

    names(anova_df) <- c("LR_Chisq", "Df", "Pr_Chisq", "Termino")
    
    return(anova_df)
  }, error = function(e) {
    warning("Error en ANOVA: ", e$message)
    return(NULL)
  })
}


variables_existentes <- variables_respuesta[variables_respuesta %in% names(datos)]

if (length(variables_existentes) == 0) {
  stop("Error: Ninguna variable de respuesta existe en los datos")
}


resultados_mlg <- list()
resultados_anova <- list()


for (variable in variables_existentes) {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("Modelando variable:", variable, "\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
 
  formula_actual <- crear_formula(variable, terminos_modelo)
  cat("Fórmula:", deparse(formula_actual), "\n\n")
  

  for (familia in familias_modelos) {
    cat("--- Ajustando modelo", familia, "---\n")
    
    modelo <- ajustar_modelo(formula_actual, datos, familia)
    
    if (!is.null(modelo)) {
   
      nombre_modelo <- paste0(variable, "_", familia)
      resultados_mlg[[nombre_modelo]] <- modelo
      
 
      anova_result <- extraer_anova(modelo, familia)
      if (!is.null(anova_result)) {
        anova_result$Variable <- variable
        anova_result$Familia <- familia
        resultados_anova[[nombre_modelo]] <- anova_result
      }
      
    
      cat("✓ Modelo ajustado exitosamente\n")
      cat("  AIC:", ifelse(!is.null(modelo$aic), round(modelo$aic, 2), "NA"), "\n")
      if (familia == "binomial_negativa") {
        cat("  Theta:", round(modelo$theta, 3), "\n")
      }
      cat("  Dispersión:", round(summary(modelo)$dispersion, 3), "\n")
      
      
      if (!is.null(anova_result)) {
        cat("\n  ANOVA (Type II LR tests):\n")
        print(anova_result[, c("Termino", "LR_Chisq", "Df", "Pr_Chisq")])
      }
      
    } else {
      cat("✗ Error ajustando modelo\n")
    }
    cat("\n")
  }
}


if (length(resultados_anova) > 0) {
 
  anova_completa <- do.call(rbind, resultados_anova)
  rownames(anova_completa) <- NULL
  
  cat("\n", paste(rep("=", 80), collapse = ""), "\n")
  cat("TABLA RESUMEN COMPLETA - ANÁLISIS DE DEVIANZA (TYPE II TESTS)\n")
  cat(paste(rep("=", 80), collapse = ""), "\n")
  

  for (variable in variables_existentes) {
    for (familia in familias_modelos) {
      nombre_modelo <- paste0(variable, "_", familia)
      if (nombre_modelo %in% names(resultados_anova)) {
        cat("\nResponse:", variable, "- Familia:", familia, "\n")
        anova_var <- resultados_anova[[nombre_modelo]]
 
        anova_display <- anova_var[, c("Termino", "LR_Chisq", "Df", "Pr_Chisq")]
        anova_display$LR_Chisq <- round(anova_display$LR_Chisq, 4)
        anova_display$Pr_Chisq <- round(anova_display$Pr_Chisq, 4)
      
        anova_display$Significancia <- ifelse(anova_display$Pr_Chisq < 0.001, "***",
                                              ifelse(anova_display$Pr_Chisq < 0.01, "**",
                                                     ifelse(anova_display$Pr_Chisq < 0.05, "*", 
                                                            ifelse(anova_display$Pr_Chisq < 0.1, ".", ""))))
        print(anova_display)
        cat("\n")
      }
    }
  }
  

  assign("modelos_mlg", resultados_mlg, envir = .GlobalEnv)
  assign("tabla_anova", anova_completa, envir = .GlobalEnv)
  assign("resultados_anova_detallados", resultados_anova, envir = .GlobalEnv)
  
  cat("✓ Modelos guardados en 'modelos_mlg'\n")
  cat("✓ Tabla ANOVA completa en 'tabla_anova'\n")
  cat("✓ Resultados ANOVA detallados en 'resultados_anova_detallados'\n")
  
} else {
  cat("No se pudo generar ningún análisis ANOVA\n")
}


if (length(resultados_anova) > 0) {
  cat("\n", paste(rep("#", 70), collapse = ""), "\n")
  cat("RESUMEN EJECUTIVO - TÉRMINOS SIGNIFICATIVOS (p < 0.05)\n")
  cat(paste(rep("#", 70), collapse = ""), "\n")
  
  significativos_encontrados <- FALSE
  
  for (variable in variables_existentes) {
    for (familia in familias_modelos) {
      nombre_modelo <- paste0(variable, "_", familia)
      if (nombre_modelo %in% names(resultados_anova)) {
        anova_var <- resultados_anova[[nombre_modelo]]
        significativos <- anova_var[anova_var$Pr_Chisq < 0.05 & !is.na(anova_var$Pr_Chisq), ]
        
        if (nrow(significativos) > 0) {
          significativos_encontrados <- TRUE
          cat("\n", variable, "(", familia, "):\n")
          for (i in 1:nrow(significativos)) {
            cat("  • ", significativos$Termino[i], 
                " (LR Chisq = ", round(significativos$LR_Chisq[i], 3),
                ", p = ", round(significativos$Pr_Chisq[i], 4), ")\n", sep = "")
          }
        }
      }
    }
  }
  
  if (!significativos_encontrados) {
    cat("\nNo se encontraron términos significativos al nivel p < 0.05\n")
  }
}


# Verificación de supuestos 

if (!require(DHARMa)) install.packages("DHARMa"); library(DHARMa)
if (!require(performance)) install.packages("performance"); library(performance)

verificar_supuestos <- function(modelo, familia, variable_nombre) {
  if (is.null(modelo)) return(NULL)
  
  cat("\n", paste(rep("-", 60), collapse = ""), "\n")
  cat("VERIFICACIÓN DE SUPUESTOS:", variable_nombre, "-", familia, "\n")
  cat(paste(rep("-", 60), collapse = ""), "\n")
  
  resultados_supuestos <- list()
  
  tryCatch({
    
    cat("\n1. ANÁLISIS DE RESIDUOS (DHARMa):\n")
    simulationOutput <- simulateResiduals(fittedModel = modelo, plot = TRUE)
    
    
    test_unif <- testUniformity(simulationOutput, plot = FALSE)
    resultados_supuestos$test_uniformidad <- test_unif$p.value
    cat("   Test de uniformidad: p =", round(test_unif$p.value, 4), 
        ifelse(test_unif$p.value < 0.05, "✗ PROBLEMA", "✓ OK"), "\n")
    
    
    test_disp <- testDispersion(simulationOutput, plot = FALSE)
    resultados_supuestos$test_dispersion <- test_disp$p.value
    cat("   Test de dispersión: p =", round(test_disp$p.value, 4),
        ifelse(test_disp$p.value < 0.05, "✗ PROBLEMA DE DISPERSIÓN", "✓ OK"), "\n")
    

    test_out <- testOutliers(simulationOutput, plot = FALSE)
    resultados_supuestos$test_outliers <- test_out$p.value
    cat("   Test de outliers: p =", round(test_out$p.value, 4),
        ifelse(test_out$p.value < 0.05, "✗ OUTLIERS DETECTADOS", "✓ OK"), "\n")
    
  }, error = function(e) {
    cat("   Error en DHARMa:", e$message, "\n")
  })
  
  tryCatch({
    
    cat("\n2. ANÁLISIS DE DISPERSIÓN:\n")
    dispersion_ratio <- summary(modelo)$dispersion
    resultados_supuestos$dispersion_ratio <- dispersion_ratio
    cat("   Ratio de dispersión:", round(dispersion_ratio, 3), "\n")
    
    if (familia == "quasipoisson") {
      if (dispersion_ratio > 1.5) {
        cat("   ⚠️  Posible overdispersion (ratio > 1.5)\n")
      } else if (dispersion_ratio < 0.5) {
        cat("   ⚠️  Posible underdispersion (ratio < 0.5)\n")
      } else {
        cat("   ✓ Dispersión adecuada para quasipoisson\n")
      }
    }
    
    if (familia == "binomial_negativa") {
      theta <- modelo$theta
      resultados_supuestos$theta <- theta
      cat("   Theta (binomial negativa):", round(theta, 3), "\n")
      if (theta < 1) {
        cat("   ⚠️  Theta bajo - puede indicar alta variabilidad\n")
      } else {
        cat("   ✓ Theta adecuado\n")
      }
    }
    
  }, error = function(e) {
    cat("   Error en análisis de dispersión:", e$message, "\n")
  })
  
  tryCatch({
   
    cat("\n3. GRÁFICO DE RESIDUOS vs AJUSTADOS:\n")
    plot(fitted(modelo), residuals(modelo, type = "deviance"),
         main = paste("Residuos vs Ajustados -", variable_nombre, "-", familia),
         xlab = "Valores Ajustados", ylab = "Residuos Deviance")
    abline(h = 0, col = "red", lty = 2)
    
  
    correlation_test <- cor.test(fitted(modelo), residuals(modelo, type = "deviance"))
    resultados_supuestos$correlacion_residuos <- correlation_test$p.value
    cat("   Correlación residuos-ajustados: p =", round(correlation_test$p.value, 4),
        ifelse(correlation_test$p.value < 0.05, "✗ PATRÓN NO ALEATORIO", "✓ OK"), "\n")
    
  }, error = function(e) {
    cat("   Error en gráfico residuos:", e$message, "\n")
  })
  
  tryCatch({
  
    cat("\n4. MULTICOLINEALIDAD (VIF):\n")
    if (length(coef(modelo)) > 2) {
      vif_values <- tryCatch({
        vif(modelo)
      }, error = function(e) {
        return(NA)
      })
      
      if (!any(is.na(vif_values))) {
        resultados_supuestos$vif <- vif_values
        cat("   Valores VIF:\n")
        for (i in 1:length(vif_values)) {
          cat("     ", names(vif_values)[i], ":", round(vif_values[i], 2), 
              ifelse(vif_values[i] > 5, "⚠️", ""), 
              ifelse(vif_values[i] > 10, "✗", ""), "\n")
        }
        
        if (any(vif_values > 10)) {
          cat("   ✗ PROBLEMA: Multicolinealidad severa (VIF > 10)\n")
        } else if (any(vif_values > 5)) {
          cat("   ⚠️  Posible multicolinealidad (VIF > 5)\n")
        } else {
          cat("   ✓ Sin problemas de multicolinealidad\n")
        }
      } else {
        cat("   No se pudo calcular VIF para este modelo\n")
      }
    } else {
      cat("   Modelo muy simple para cálculo de VIF\n")
    }
    
  }, error = function(e) {
    cat("   Error en VIF:", e$message, "\n")
  })
  
  return(resultados_supuestos)
}



cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("INICIANDO VERIFICACIÓN DE SUPUESTOS PARA TODOS LOS MODELOS\n")
cat(paste(rep("=", 80), collapse = ""), "\n")


resultados_supuestos <- list()


for (variable in variables_existentes) {
  for (familia in familias_modelos) {
    nombre_modelo <- paste0(variable, "_", familia)
    if (nombre_modelo %in% names(resultados_mlg)) {
      modelo <- resultados_mlg[[nombre_modelo]]
      supuestos <- verificar_supuestos(modelo, familia, variable)
      resultados_supuestos[[nombre_modelo]] <- supuestos
      
     
      cat("\n")
      Sys.sleep(1)
    }
  }
}



cat("\n", paste(rep("#", 80), collapse = ""), "\n")
cat("RESUMEN FINAL - VERIFICACIÓN DE SUPUESTOS\n")
cat(paste(rep("#", 80), collapse = ""), "\n")

problemas_detectados <- FALSE

for (variable in variables_existentes) {
  for (familia in familias_modelos) {
    nombre_modelo <- paste0(variable, "_", familia)
    if (nombre_modelo %in% names(resultados_supuestos)) {
      supuestos <- resultados_supuestos[[nombre_modelo]]
      
    
      problemas <- c()
      
      if (!is.null(supuestos$test_uniformidad) && supuestos$test_uniformidad < 0.05) {
        problemas <- c(problemas, "Residuos no uniformes")
      }
      if (!is.null(supuestos$test_dispersion) && supuestos$test_dispersion < 0.05) {
        problemas <- c(problemas, "Problemas de dispersión")
      }
      if (!is.null(supuestos$test_outliers) && supuestos$test_outliers < 0.05) {
        problemas <- c(problemas, "Outliers significativos")
      }
      if (!is.null(supuestos$correlacion_residuos) && supuestos$correlacion_residuos < 0.05) {
        problemas <- c(problemas, "Patrón en residuos")
      }
      
      if (length(problemas) > 0) {
        problemas_detectados <- TRUE
        cat("\n⚠️  ", variable, "(", familia, "):\n")
        cat("    Problemas:", paste(problemas, collapse = ", "), "\n")
      } else {
        cat("\n✓  ", variable, "(", familia, "): Supuestos cumplidos adecuadamente\n")
      }
    }
  }
}

if (!problemas_detectados) {
  cat("\n✅ TODOS LOS MODELOS CUMPLEN ADECUADAMENTE CON LOS SUPUESTOS\n")
} else {
  cat("\n🔴 ALGUNOS MODELOS PRESENTAN PROBLEMAS EN LOS SUPUESTOS - INTERPRETAR CON CAUTELA\n")
}


assign("resultados_supuestos", resultados_supuestos, envir = .GlobalEnv)
cat("\n✓ Resultados de supuestos guardados en 'resultados_supuestos'\n")


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RECOMENDACIONES:\n")
cat("• Modelos con problemas de uniformidad: considerar transformaciones\n")        # Recomendaciones generales
cat("• Modelos con overdispersion: binomial negativa suele ser mejor opción\n")
cat("• Modelos con underdispersion: Poisson puede ser adecuado\n")
cat("• Presencia de outliers: verificar datos y considerar modelos robustos\n")
cat("• Multicolinealidad: simplificar el modelo o remover predictores correlacionados\n")
cat(paste(rep("=", 80), collapse = ""), "\n")


# Prueba múltiple de medias y gráfico de líneas de error

if (!require(emmeans)) install.packages("emmeans"); library(emmeans)
if (!require(multcomp)) install.packages("multcomp"); library(multcomp)
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)
if (!require(multcompView)) install.packages("multcompView"); library(multcompView)


nivel_significancia <- 0.15 # ajustar


realizar_prueba_medias <- function(modelo, variable_nombre, familia, termino, alpha = 0.15) {
  if (is.null(modelo)) return(NULL)
  
  cat("\n", paste(rep("-", 60), collapse = ""), "\n")
  cat("PRUEBA MÚLTIPLE DE MEDIAS:", variable_nombre, "-", familia, "\n")
  cat("Término:", termino, "- Nivel de significancia:", alpha, "\n")
  cat(paste(rep("-", 60), collapse = ""), "\n")
  
  tryCatch({
    
    emm <- emmeans(modelo, specs = termino, type = "response")
    
    
    comparaciones <- pairs(emm, adjust = "tukey")
    
    
    letras <- cld(emm, alpha = alpha, Letters = letters, adjust = "tukey")
    
    
    cat("\nMedias marginales estimadas:\n")
    print(emm)
    
    cat("\nComparaciones múltiples (Tukey):\n")
    print(comparaciones)
    
    cat("\nLetras de significancia (alpha =", alpha, "):\n")
    print(letras)
    
    return(list(emm = emm, comparaciones = comparaciones, letras = letras))
    
  }, error = function(e) {
    cat("Error en prueba de medias:", e$message, "\n")
    return(NULL)
  })
}


crear_grafico_lineas_error <- function(resultados_medias, variable_nombre, familia, termino) {
  if (is.null(resultados_medias)) return(NULL)
  
  letras <- resultados_medias$letras
  emm <- resultados_medias$emm
  
  
  plot_data <- as.data.frame(emm)
  
  # **CORRECCIÓN 1: Identificación de nombres de columnas de IC**
  ic_names <- names(plot_data)[grep("\\.LCL$|\\.UCL$", names(plot_data))]
  LCL_name <- ic_names[grep("\\.LCL$", ic_names)]
  UCL_name <- ic_names[grep("\\.UCL$", ic_names)]
  
  # Determinar el nombre de la columna de la media estimada (response o emmean)
  mean_name <- ifelse("response" %in% names(plot_data), "response", "emmean")
  
  
  plot_data$.group <- letras$.group
  
  
  p <- ggplot(plot_data, aes(x = .data[[names(plot_data)[1]]], y = .data[[mean_name]])) +
    geom_point(size = 3, color = "blue") +
    geom_line(aes(group = 1), linetype = "dashed", alpha = 0.5, color = "blue") +
    geom_errorbar(aes(ymin = .data[[LCL_name]], ymax = .data[[UCL_name]]), # <--- CORRECCIÓN aplicada
                  width = 0.2, linewidth = 0.8, color = "blue") +
    geom_text(aes(label = .group, y = .data[[UCL_name]]), # <--- CORRECCIÓN aplicada
              vjust = -0.8, size = 4, fontface = "bold", color = "red") +
    labs(title = paste("Medias de", variable_nombre, "-", familia),
         subtitle = paste("Término:", termino),
         x = termino,
         y = paste("Media Estimada de", variable_nombre), # Cambio para ser más preciso
         caption = paste("Letras diferentes indican diferencias significativas (α =", nivel_significancia, ")")) +
    theme_minimal() +
    theme(plot.title = element_text(face = "bold", size = 12),
          axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
  return(p)
}


crear_grafico_lineas_error_alt <- function(resultados_medias, variable_nombre, familia, termino) {
  if (is.null(resultados_medias)) return(NULL)
  
  letras <- resultados_medias$letras
  
  
  plot_data <- as.data.frame(letras)
  
  
  names(plot_data) <- tolower(names(plot_data))
  
  # **CORRECCIÓN 2: Uso de nombres 'response' / 'asymp.lcl'**
  # La media es 'response' o 'emmean', el IC es 'asymp.lcl' / 'asymp.ucl'
  
  mean_name <- ifelse("response" %in% names(plot_data), "response", "emmean")
  LCL_name <- ifelse("asymp.lcl" %in% names(plot_data), "asymp.lcl", "lower.cl")
  UCL_name <- ifelse("asymp.ucl" %in% names(plot_data), "asymp.ucl", "upper.cl")
  
  
  if (!LCL_name %in% names(plot_data)) { # Si aún no encuentra los nombres, usar SE (menos preciso)
    
    plot_data$temp_lcl <- plot_data$emmean - plot_data$se * 1.96
    plot_data$temp_ucl <- plot_data$emmean + plot_data$se * 1.96
    LCL_name <- "temp_lcl"
    UCL_name <- "temp_ucl"
    warning("Usando IC basado en SE * 1.96, no los límites asintóticos reales.")
  }
  
  # **Aplicar CORRECCIÓN 2 en el gráfico**
  p <- ggplot(plot_data, aes(x = .data[[names(plot_data)[1]]], y = .data[[mean_name]])) +
    geom_point(size = 3, color = "blue") +
    geom_line(aes(group = 1), linetype = "dashed", alpha = 0.5, color = "blue") +
    geom_errorbar(aes(ymin = .data[[LCL_name]], ymax = .data[[UCL_name]]), # <--- CORRECCIÓN aplicada
                  width = 0.2, linewidth = 0.8, color = "blue") +
    geom_text(aes(label = .group, y = .data[[UCL_name]]), # <--- CORRECCIÓN aplicada
              vjust = -0.8, size = 4, fontface = "bold", color = "red") +
    labs(title = paste("Medias de", variable_nombre, "-", familia),
         subtitle = paste("Término:", termino),
         x = termino,
         y = paste("Media Estimada de", variable_nombre), # Cambio para ser más preciso
         caption = paste("Letras diferentes indican diferencias significativas (α =", nivel_significancia, ")")) +
    theme_minimal() +
    theme(plot.title = element_text(face = "bold", size = 14),
          axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
  return(p)
}


crear_grafico_bigotes <- function(datos, variable_nombre, termino) {
  
  if (!termino %in% names(datos)) {
    cat("El término", termino, "no existe en los datos\n")
    return(NULL)
  }
  
  
  p <- ggplot(datos, aes(x = .data[[termino]], y = .data[[variable_nombre]])) +
    geom_boxplot(width = 0.3, alpha = 0.7, outlier.shape = NA) +
    geom_jitter(width = 0.1, alpha = 0.6, size = 1.5, color = "blue") +
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +
    labs(title = paste("Distribución de", variable_nombre),
         subtitle = paste("Por niveles de", termino),
         x = termino,
         y = variable_nombre) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
  return(p)
}


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("INICIANDO PRUEBAS MÚLTIPLES DE MEDIAS Y GRÁFICOS\n")
cat("Nivel de significancia:", nivel_significancia, "\n")
cat(paste(rep("=", 80), collapse = ""), "\n")


resultados_medias <- list()
graficos_medias <- list()
graficos_bigotes <- list()


terminos_para_medias <- c("Tratamiento") # Ajustar según las FV

# Bucle principal
for (variable in variables_existentes) {
  for (familia in familias_modelos) {
    nombre_modelo <- paste0(variable, "_", familia)
    
    if (nombre_modelo %in% names(resultados_mlg)) {
      modelo <- resultados_mlg[[nombre_modelo]]
      
      cat("\n", paste(rep("*", 70), collapse = ""), "\n")
      cat("PROCESANDO:", variable, "-", familia, "\n")
      cat(paste(rep("*", 70), collapse = ""), "\n")
      
      
      for (termino in terminos_para_medias) {
        if (termino %in% all.vars(formula(modelo))) {
          
          resultados <- realizar_prueba_medias(modelo, variable, familia, termino, nivel_significancia)
          
          if (!is.null(resultados)) {
            
            key <- paste0(variable, "_", familia, "_", termino)
            resultados_medias[[key]] <- resultados
            
            
            cat("\nGenerando gráfico de líneas de error...\n")
            grafico <- crear_grafico_lineas_error_alt(resultados, variable, familia, termino)
            graficos_medias[[key]] <- grafico
            
            
            cat("Generando gráfico de bigotes...\n")
            grafico_bigotes <- crear_grafico_bigotes(datos, variable, termino)
            graficos_bigotes[[key]] <- grafico_bigotes
            
            
            Sys.sleep(1)
          }
        }
      }
    }
  }
}


############# Porcentajes ########################
names(datos)

factores_prop <- c("Tratamiento", "Replica")
variables_proporciones <- c("porcentaje_de_parasitoidismo")
terminos_modelo_prop <- c("Tratamiento", "Replica")
familias_modelos_prop <- c("quasibinomial", "beta")  # se ajustan ambos; pruebas/plots se hacen para quasibinomial
escala_variables <- list(
  Porc_captura = "porcentaje",
  Proporcion_exito = "proporcion"
)


detectar_escala <- function(valores) {
  if (all(valores >= 0 & valores <= 1, na.rm = TRUE)) return("proporcion")
  if (all(valores >= 0 & valores <= 100, na.rm = TRUE)) return("porcentaje")
  return("desconocida")
}

transformar_a_proporcion <- function(datos, variables, escalas) {
  datos2 <- datos
  for (v in variables) {
    if (!v %in% names(datos2)) next
    escala <- escalas[[v]]
    vals <- datos2[[v]]
    if (is.null(escala)) {
      escala <- detectar_escala(vals)
      message("Variable ", v, " detectada como: ", escala)
    }
    if (escala == "porcentaje") {
      datos2[[v]] <- vals / 100
      message("Variable ", v, " transformada de porcentaje a proporción")
    } else if (escala == "desconocida") {
      warning("Escala desconocida para ", v, ". Valores entre ",
              min(vals, na.rm = TRUE), " y ", max(vals, na.rm = TRUE))
    }
  }
  datos2
}

crear_formula_prop <- function(respuesta, terminos) {
  as.formula(paste0(respuesta, " ~ ", paste(terminos, collapse = " + ")))
}

ajustar_modelo_prop <- function(formula, datos, familia, variable) {
  tryCatch({
    if (familia == "beta") {
      # transformacion recomendada para beta (evitar 0/1)
      y <- model.response(model.frame(formula, datos))
      n <- length(y)
      y_transf <- (y * (n - 1) + 0.5) / n
      datos_temp <- datos
      datos_temp[[variable]] <- y_transf
      betareg::betareg(formula, data = datos_temp)
    } else {
      glm(formula, data = datos, family = quasibinomial())
    }
  }, error = function(e) {
    warning("Error ajustando modelo (", familia, "): ", e$message)
    NULL
  })
}

extraer_anova_prop <- function(modelo, familia, terminos_completos) {
  if (is.null(modelo)) return(NULL)
  tryCatch({
    if (familia == "quasibinomial") {
      a <- car::Anova(modelo, type = "II", test = "F")
      adf <- as.data.frame(a)
      adf$Termino <- rownames(adf)
      rownames(adf) <- NULL
      names(adf)[1:4] <- c("F_value", "Df", "Df_res", "Pr_F")
      adf[, c("Termino", "F_value", "Df", "Df_res", "Pr_F")]
    } else if (familia == "beta") {
      # Likelihood ratio tests por término (beta)
      resultados <- data.frame()
      formula_completa <- stats::formula(modelo)
      for (termino in terminos_completos) {
        tryCatch({
          terminos_sin <- terminos_completos[terminos_completos != termino]
          if (length(terminos_sin) == 0) next
          fr <- crear_formula_prop(as.character(formula_completa)[2], terminos_sin)
          mod_red <- betareg::betareg(fr, data = modelo$model)
          test_lr <- lmtest::lrtest(mod_red, modelo)
          p_valor <- as.numeric(test_lr[2, "Pr(>Chisq)"])
          lr_chisq <- 2 * (logLik(modelo) - logLik(mod_red))
          resultados <- rbind(resultados,
                              data.frame(Termino = termino,
                                         Chisq = round(as.numeric(lr_chisq), 4),
                                         Df = NA,
                                         Pr_Chisq = round(p_valor, 4),
                                         stringsAsFactors = FALSE))
        }, error = function(e) {
          warning("Error test LR en termino ", termino, ": ", e$message)
        })
      }
      resultados
    }
  }, error = function(e) {
    warning("Error en ANOVA de proporciones: ", e$message)
    NULL
  })
}

extraer_resumen_beta <- function(modelo) {
  if (is.null(modelo)) return(NULL)
  tryCatch({
    s <- summary(modelo)
    coefm <- s$coefficients$mean
    data.frame(Parametro = rownames(coefm),
               Coeficiente = coefm[, "Estimate"],
               Error_Std = coefm[, "Std. Error"],
               z_value = coefm[, "z value"],
               Pr_z = coefm[, "Pr(>|z|)"],
               stringsAsFactors = FALSE)
  }, error = function(e) {
    warning("Error resumen beta: ", e$message)
    NULL
  })
}

# ----------------------------------------------------------
# Inicio del análisis: transformación y comprobaciones
# ----------------------------------------------------------
datos_prop <- transformar_a_proporcion(datos, variables_proporciones, escala_variables)

variables_existentes_prop <- intersect(variables_proporciones, names(datos_prop))
if (length(variables_existentes_prop) == 0) stop("No se encontró ninguna variable de proporción en los datos")

# Preparar contenedores
resultados_prop <- list()
resultados_anova_prop <- list()
resultados_coeficientes_prop <- list()


for (variable in variables_existentes_prop) {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("Modelando:", variable, "\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  formula_actual <- crear_formula_prop(variable, terminos_modelo_prop)
  cat("Fórmula:", deparse(formula_actual), "\n")
  
  for (familia in familias_modelos_prop) {
    cat(" Ajustando familia:", familia, "...\n")
    modelo <- ajustar_modelo_prop(formula_actual, datos_prop, familia, variable)
    if (is.null(modelo)) {
      cat("  ✗ Error: modelo no ajustado\n")
      next
    }
    nombre_modelo <- paste0(variable, "_", familia)
    resultados_prop[[nombre_modelo]] <- modelo
    cat("  ✓ Modelo ajustado:", nombre_modelo, "\n")
    
    if (familia == "quasibinomial") {
      # información adicional
      cat("   Dispersión:", round(summary(modelo)$dispersion, 3), "\n")
      cat("   AIC:", round(AIC(modelo), 2), "\n")
      anova_res <- extraer_anova_prop(modelo, familia, terminos_modelo_prop)
      if (!is.null(anova_res)) {
        anova_res$Variable <- variable
        anova_res$Familia <- familia
        resultados_anova_prop[[nombre_modelo]] <- anova_res
        cat("   ANOVA (Type II F-tests):\n"); print(anova_res[, c("Termino","F_value","Df","Pr_F")])
      }
    } else if (familia == "beta") {
      cat("   Pseudo R2:", round(summary(modelo)$pseudo.r.squared, 3), "\n")
      cat("   LogLik:", round(logLik(modelo), 2), "\n")
      coef_res <- extraer_resumen_beta(modelo)
      if (!is.null(coef_res)) {
        coef_res$Variable <- variable
        coef_res$Familia <- familia
        resultados_coeficientes_prop[[nombre_modelo]] <- coef_res
        cat("   COEFICIENTES (beta):\n"); print(coef_res[, c("Parametro","Coeficiente","Pr_z")])
      }
      # intentar ANOVA para beta
      anova_alt <- extraer_anova_prop(modelo, familia, terminos_modelo_prop)
      if (!is.null(anova_alt)) {
        anova_alt$Variable <- variable
        anova_alt$Familia <- familia
        resultados_anova_prop[[nombre_modelo]] <- anova_alt
        cat("   ANOVA (LR tests):\n"); print(anova_alt)
      }
    }
    cat("\n")
  }
}


###################################################################
#Prueba múltiple de medias

config_grafico <- list(
  factor_principal = "Tratamiento",
  
  alpha = 0.15,             # Significancia
  mostrar_linea = FALSE,     # Línea que une medias
  
  color_linea = "black",
  grosor_linea = 1,
  
  color_punto = "red",
  tamaño_punto = 4,
  
  grosor_error = 1,
  ancho_error = 0.15
)


for (nombre_modelo in names(resultados_prop)) {
  
  modelo_act <- resultados_prop[[nombre_modelo]]
  
  split_name <- unlist(strsplit(nombre_modelo, "_"))
  variable <- paste(split_name[1:(length(split_name)-1)], collapse = "_")
  familia <- split_name[length(split_name)]
  
  cat("\n------------------------------------------------------------\n")
  cat("Variable:", variable, "- Familia:", familia, "\n")
  cat("Solo comparaciones por TRATAMIENTO\n")
  cat("------------------------------------------------------------\n")
  
  factor_usado <- config_grafico$factor_principal
  
  if (!(factor_usado %in% names(modelo_act$model))) {
    cat("El factor configurado no está en el modelo. Saltando...\n")
    next
  }
  

  emms <- tryCatch({
    emmeans(modelo_act, specs = factor_usado)
  }, error = function(e) {
    cat("Error en EMMs:", e$message, "\n")
    return(NULL)
  })
  
  if (is.null(emms)) next
  

  comparaciones <- tryCatch({
    pairs(emms, adjust = "tukey")
  }, error = function(e) {
    cat("Error en comparaciones múltiples:", e$message, "\n")
    return(NULL)
  })
  
  print(comparaciones)
  

  letras <- tryCatch({
    multcomp::cld(emms, adjust = "tukey", Letters = letters)
  }, error = function(e) {
    cat("Error generando letras:", e$message, "\n")
    return(NULL)
  })
  
  df_plot <- as.data.frame(letras)
  df_plot <- df_plot %>% mutate(y_pos = emmean + SE * 1.3)
  

  cat("\nTabla de medias marginales (solo por tratamiento):\n")
  print(df_plot[, c(factor_usado, "emmean", "SE", ".group")])
  
  # -------------- GRÁFICO DINÁMICO -------------------
  
  g <- ggplot(df_plot, aes_string(x = factor_usado, y = "emmean")) +
    
    # Punto
    geom_point(size = config_grafico$tamaño_punto,
               color = config_grafico$color_punto) +
    
    # Línea opcional
    { if (config_grafico$mostrar_linea)
      geom_line(group = 1,
                linewidth = config_grafico$grosor_linea,
                color = config_grafico$color_linea)
    } +
    
    # Barras de error
    geom_errorbar(
      aes(ymin = emmean - SE, ymax = emmean + SE),
      width = config_grafico$ancho_error,
      linewidth = config_grafico$grosor_error
    ) +
    
    # Letras
    geom_text(aes(label = .group, y = y_pos),
              vjust = 0, size = 5) +
    
    labs(
      title = paste("Medias marginales por tratamiento -", variable, "(", familia, ")"),
      x = config_grafico$factor_principal,
      y = paste("Media marginal de", variable)
    ) +
    theme_bw(base_size = 14)
  
  print(g)
}



######################################################################################################

names(datos)

if (!require(betareg)) install.packages("betareg"); library(betareg)
if (!require(emmeans)) install.packages("emmeans"); library(emmeans)
if (!require(car)) install.packages("car"); library(car)
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)
if (!require(scales)) install.packages("scales"); library(scales)
if (!require(lmtest)) install.packages("lmtest"); library(lmtest)



factores_prop <- c("Tratamiento", "Replica")


variables_proporciones <- c("porcentaje_de_parasitoidismo")  


terminos_modelo_prop <- c("Tratamiento", "Replica")


familias_modelos_prop <- c("quasibinomial", "beta")  # quasibinomial, beta


escala_variables <- list(
  Porc_captura = "porcentaje",    # "proporcion" o "porcentaje"
  Proporcion_exito = "proporcion" # "proporcion" o "porcentaje"
)


detectar_escala <- function(valores) {
  if (all(valores >= 0 & valores <= 1, na.rm = TRUE)) {
    return("proporcion")
  } else if (all(valores >= 0 & valores <= 100, na.rm = TRUE)) {
    return("porcentaje")
  } else {
    return("desconocida")
  }
}


transformar_a_proporcion <- function(datos, variables, escalas) {
  datos_transformados <- datos
  for (variable in variables) {
    if (variable %in% names(datos)) {
      escala <- escalas[[variable]]
      valores <- datos[[variable]]
      
      
      if (is.null(escala)) {
        escala <- detectar_escala(valores)
        cat("🔍 Variable", variable, "detectada como:", escala, "\n")
      }
      
      if (escala == "porcentaje") {
        datos_transformados[[variable]] <- valores / 100
        cat("✓ Variable", variable, "transformada de porcentaje a proporción\n")
      } else if (escala == "desconocida") {
        cat("⚠️  Advertencia: La variable", variable, "tiene escala desconocida\n")
        cat("   Valores entre", min(valores, na.rm = TRUE), "y", max(valores, na.rm = TRUE), "\n")
      }
    }
  }
  return(datos_transformados)
}


crear_formula_prop <- function(respuesta, terminos) {
  formula_str <- paste0(respuesta, " ~ ", paste(terminos, collapse = " + "))
  as.formula(formula_str)
}


ajustar_modelo_prop <- function(formula, datos, familia, variable) {
  tryCatch({
    
    if (familia == "beta") {
      y <- model.response(model.frame(formula, datos))
      
      n <- length(y)
      y_transf <- (y * (n - 1) + 0.5) / n
      datos_temp <- datos
      datos_temp[[variable]] <- y_transf
      modelo <- betareg(formula, data = datos_temp)
    } else {
      modelo <- glm(formula, data = datos, family = quasibinomial())
    }
    return(modelo)
  }, error = function(e) {
    warning("Error ajustando modelo de proporciones: ", e$message)
    return(NULL)
  })
}


extraer_anova_prop <- function(modelo, familia, terminos_completos) {
  if (is.null(modelo)) return(NULL)
  
  tryCatch({
    if (familia == "quasibinomial") {
      
      anova_result <- Anova(modelo, type = "II", test = "F")
      anova_df <- as.data.frame(anova_result)
      anova_df$Termino <- rownames(anova_df)
      rownames(anova_df) <- NULL
      names(anova_df) <- c("F_value", "Df", "Df_res", "Pr_F", "Termino")
      return(anova_df)
      
    } else if (familia == "beta") {
      
      cat("   Calculando ANOVA para beta regresión (tests LR)...\n")
      
      
      resultados_anova <- data.frame()
      formula_completa <- formula(modelo)
      
      for (termino in terminos_completos) {
        tryCatch({
          
          if (grepl(":", termino)) {
            
            terminos_sin <- terminos_completos[terminos_completos != termino]
          } else {
            terminos_sin <- terminos_completos[terminos_completos != termino]
          }
          
          if (length(terminos_sin) > 0) {
            formula_reducida <- crear_formula_prop(as.character(formula_completa)[2], terminos_sin)
            modelo_reducido <- betareg(formula_reducida, data = modelo$model)
            
            
            test_lr <- lrtest(modelo_reducido, modelo)
            lr_chisq <- 2 * (logLik(modelo) - logLik(modelo_reducido))
            p_valor <- test_lr[["Pr(>Chisq)"]][2]
            
            resultados_anova <- rbind(resultados_anova, data.frame(
              Termino = termino,
              Chisq = round(lr_chisq, 4),
              Df = attr(lr_chisq, "df"),
              Pr_Chisq = round(p_valor, 4)
            ))
          }
        }, error = function(e) {
          cat("   Error calculando test para término", termino, ":", e$message, "\n")
        })
      }
      
      return(resultados_anova)
    }
    
  }, error = function(e) {
    warning("Error en ANOVA de proporciones: ", e$message)
    return(NULL)
  })
}


extraer_resumen_beta <- function(modelo) {
  if (is.null(modelo)) return(NULL)
  
  tryCatch({
    sumario <- summary(modelo)
    coeficientes <- sumario$coefficients$mean
    
    
    resultados <- data.frame(
      Parametro = rownames(coeficientes),
      Coeficiente = coeficientes[, "Estimate"],
      Error_Std = coeficientes[, "Std. Error"],
      z_value = coeficientes[, "z value"],
      Pr_z = coeficientes[, "Pr(>|z|)"]
    )
    
    return(resultados)
  }, error = function(e) {
    cat("Error en resumen beta:", e$message, "\n")
    return(NULL)
  })
}



cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("INICIANDO ANÁLISIS PARA PROPORCIONES Y PORCENTAJES\n")
cat(paste(rep("=", 80), collapse = ""), "\n")


datos_prop <- transformar_a_proporcion(datos, variables_proporciones, escala_variables)


variables_existentes_prop <- variables_proporciones[variables_proporciones %in% names(datos_prop)]

if (length(variables_existentes_prop) == 0) {
  stop("Error: Ninguna variable de proporción existe en los datos")
}


resultados_prop <- list()
resultados_anova_prop <- list()
resultados_coeficientes_prop <- list()


for (variable in variables_existentes_prop) {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("Modelando proporción:", variable, "\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  
  formula_actual <- crear_formula_prop(variable, terminos_modelo_prop)
  cat("Fórmula:", deparse(formula_actual), "\n\n")
  
  
  for (familia in familias_modelos_prop) {
    cat("--- Ajustando modelo", familia, "---\n")
    
    modelo <- ajustar_modelo_prop(formula_actual, datos_prop, familia, variable)
    
    if (!is.null(modelo)) {
      
      nombre_modelo <- paste0(variable, "_", familia)
      resultados_prop[[nombre_modelo]] <- modelo
      
      
      cat("✓ Modelo ajustado exitosamente\n")
      
      if (familia == "quasibinomial") {
        cat("  Dispersión:", round(summary(modelo)$dispersion, 3), "\n")
        cat("  AIC:", round(AIC(modelo), 2), "\n")
        
        
        anova_result <- extraer_anova_prop(modelo, familia, terminos_modelo_prop)
        if (!is.null(anova_result)) {
          anova_result$Variable <- variable
          anova_result$Familia <- familia
          resultados_anova_prop[[nombre_modelo]] <- anova_result
          
          cat("\n  ANOVA (Type II F-tests):\n")
          anova_display <- anova_result[, c("Termino", "F_value", "Df", "Pr_F")]
          anova_display$Pr_F <- round(anova_display$Pr_F, 4)
          print(anova_display)
        }
        
      } else if (familia == "beta") {
        cat("  Pseudo R²:", round(summary(modelo)$pseudo.r.squared, 3), "\n")
        cat("  Log-verosimilitud:", round(logLik(modelo), 2), "\n")
        
        
        coef_result <- extraer_resumen_beta(modelo)
        if (!is.null(coef_result)) {
          coef_result$Variable <- variable
          coef_result$Familia <- familia
          resultados_coeficientes_prop[[nombre_modelo]] <- coef_result
          
          cat("\n  COEFICIENTES (modelo beta):\n")
          coef_display <- coef_result[, c("Parametro", "Coeficiente", "Pr_z")]
          coef_display$Coeficiente <- round(coef_display$Coeficiente, 4)
          coef_display$Pr_z <- round(coef_display$Pr_z, 4)
          coef_display$Significancia <- ifelse(coef_display$Pr_z < 0.001, "***",
                                               ifelse(coef_display$Pr_z < 0.01, "**",
                                                      ifelse(coef_display$Pr_z < 0.05, "*", 
                                                             ifelse(coef_display$Pr_z < 0.1, ".", ""))))
          print(coef_display)
        }
        
        
        cat("\n  Intentando ANOVA alternativo para beta...\n")
        anova_alt <- tryCatch({
          extraer_anova_prop(modelo, familia, terminos_modelo_prop)
        }, error = function(e) {
          cat("   No se pudo calcular ANOVA para beta regresión\n")
          return(NULL)
        })
        
        if (!is.null(anova_alt)) {
          anova_alt$Variable <- variable
          anova_alt$Familia <- familia
          resultados_anova_prop[[nombre_modelo]] <- anova_alt
          cat("  ANOVA (Likelihood Ratio Tests):\n")
          print(anova_alt)
        }
      }
      
    } else {
      cat("✗ Error ajustando modelo\n")
    }
    cat("\n")
  }
}

######################################################################################################
attach(datos)
names(datos)
variables <- datos[, c("tch", "peso_neto", "metros_lineales")] #Solo para variables cuantitativas
pca <- PCA(variables, scale.unit = TRUE, graph = FALSE) #Escalar

#Gráfico de variables
fviz_pca_ind(pca, 
             geom.ind = "point",
             col.ind = datos$Tratamiento,   # variable categórica
             palette = "jco",
             addEllipses = TRUE,
             legend.title = "Grupo")

#Biplot
fviz_pca_biplot(pca, 
                col.ind = datos$Tratamiento,
                palette = "jco",
                addEllipses = TRUE,
                label = "var",
                col.var = "black")
#Gráfico de variables
fviz_pca_var(pca,
             col.var = "contrib",     # colorea por contribución al eje
             gradient.cols = c("blue", "blue", "red"),
             repel = TRUE)            # evita que se sobrepongan las etiquetas




#Correlación
plot(tch, peso_neto, col= "red", pch = 16, pty = 1)
plot(tch, metros_lineales, col = "blue", pch = 16)

correlacion<- cor.test(tch, peso_neto, method = "pearson", alternative = "two.sided", conf.level = 0.95 )
print(correlacion)

correlacion<- cor.test(tch, metros_lineales, method = "pearson", alternative = "two.sided", conf.level = 0.95 )
print(correlacion)



# Matriz de correlación
variables_correlacion <- datos %>%
  select(tch, peso_neto, metros_lineales)

matriz_cor <- cor(variables_correlacion, use = "complete.obs", method = "pearson")

cat("MATRIZ DE CORRELACIÓN DE PEARSON\n")
print(round(matriz_cor, 3))




# Andeva y post Andeva, con agricolae
library(lme4)       # Motor del modelo mixto
library(lmerTest)   # Para obtener p-values en la tabla ANOVA
library(emmeans)    # Para medias ajustadas y comparaciones (reemplaza a HSD.test)
library(multcomp)   # Necesario para las letras de significancia (cld)
library(multcompView)
library(ggplot2)
datos <- na.omit(datos)  # Eliminar filas con NA

# 1. Ajuste del Modelo Mixto
# Sintaxis: variable_fija + (1 | variable_aleatoria)
# Aquí 'Trat' es fijo y 'Surcos_cosechados' es el intercepto aleatorio
model_mixed <- lm(tch ~ Tratamiento, data = datos)

# 2. Tabla ANOVA (Tipo III con Satterthwaite approximation para grados de libertad)
print("--- Tabla ANOVA (Modelo Mixto) ---")
print(anova(model_mixed))

# 3. Post hoc Tukey (Medias Marginales Estimadas)
# Calculamos las medias ajustadas por el efecto aleatorio
emm <- emmeans(model_mixed, ~ Tratamiento)

# Generamos las letras (Compact Letter Display)
# IMPORTANTE: alpha = 0.15
tukey_mixed <- cld(emm, 
                   alpha = 0.15, 
                   Letters = letters, 
                   adjust = "tukey") # Ajuste de Tukey para comparaciones múltiples

print("--- Medias Ajustadas y Grupos (Tukey) ---")
print(tukey_mixed)

# 4. Preparación de datos para gráfico
# Convertimos a data.frame para ggplot
plot_data <- as.data.frame(tukey_mixed)

# Nota: emmeans crea la columna 'emmean' (Estimated Marginal Mean) en lugar de 'TCH'
# Renombramos columna de letras para facilitar (normalmente se llama .group)
colnames(plot_data)[colnames(plot_data) == ".group"] <- "groups"

# Limpiamos espacios en blanco que a veces deja multcomp en las letras
plot_data$groups <- trimws(plot_data$groups)

# 5. Gráfico de Puntos de Medias Ajustadas (Estilo de Publicación)
ggplot(plot_data, aes(x = reorder(Tratamiento, emmean), y = emmean)) + 
  # 1. Barras de Error (CI 85% - ajustado a alpha=0.15)
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), 
                width = 0.2, size = 1, color = "gray50") +
  # 2. Puntos (Medias Estimadas)
  geom_point(size = 4, color = "black", fill = "red", shape = 21) + 
  # 3. Línea para conectar si el tratamiento tiene un orden inherente (opcional)
  # geom_line(aes(group = 1), color = "gray50", linetype = "dotted") +
  
  # 4. Letras de Signifiancia
  geom_text(aes(label = groups), vjust = -2, size = 5, fontface = "bold") +
  
  labs(title = "Comparación de TCH (Medias Ajustadas - Modelo Mixto)",
       subtitle = "Letras de significancia ajustadas por Tukey (alpha = 0.15)",
       x = "Tratamiento",
       y = "TCH Promedio Estimado") +
  
  # 5. Tema minimalista y limpio
  theme_bw() + # Tema blanco y negro, muy común en publicaciones
  theme(
    panel.grid.major.x = element_blank(), # Eliminamos líneas verticales
    panel.grid.minor.y = element_blank(), # Eliminamos líneas horizontales menores
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 12), # Quitamos rotación
    axis.title.y = element_text(size = 14, margin = margin(r = 10)),
    axis.title.x = element_text(size = 14, margin = margin(t = 10))
  )





# 1. MODELO BINOMIAL NEGATIVA
attach(datos)
modelo_nb <- glm.nb(datos$ind_m2 ~ datos$Tratamiento + datos$Replica, data = datos)
summary(modelo_nb)
Anova(modelo_nb)

sim_res_nb <- simulateResiduals(fittedModel = modelo_nb, n = 1000)
plot(sim_res_nb)
testDispersion(sim_res_nb)

ems_nb_trat <- emmeans(modelo_nb, ~ Tratamiento, type = "response")
pairs_nb_trat <- pairs(ems_nb_trat, adjust = "tukey")
print(ems_nb_trat)
print(pairs_nb_trat)




# Cargar librerías necesarias
library(emmeans)
library(multcomp)
library(ggplot2)
library(dplyr)

# 1. Generar el Compact Letter Display
cld_nb_trat <- cld(ems_nb_trat,
                   alpha = 0.15,
                   Letters = LETTERS,
                   adjust = "tukey")

# 2. Convertir el resultado a un data frame y preparar la columna de etiquetas
cld_df <- as.data.frame(cld_nb_trat)

# NOTA: Imprime los nombres de las columnas para verificar, si el error persiste:
# print(names(cld_df)) 

# Crear la columna de etiquetas
cld_df <- cld_df %>%
  mutate(etiqueta = .group)

# 3. Creación del Gráfico de Líneas de Error, USANDO NOMBRES CORRECTOS:
grafico_tukey_nb <- ggplot(cld_df, aes(x = Tratamiento, y = response)) + # <--- ¡CAMBIO CLAVE AQUÍ!
  
  # Bigotes (Intervalos de Confianza)
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                width = 0.2,
                linewidth = 0.8,
                color = "gray40") +
  
  # Puntos (Medias Estimadas)
  geom_point(size = 4, color = "red") +
  
  # Etiquetas de Letras de Tukey (colocadas por encima del bigote superior)
  geom_text(aes(label = etiqueta, y = asymp.UCL),
            vjust = -0.5,
            size = 5,
            color = "black",
            fontface = "bold") +
  
  # Ajustes estéticos y títulos
  labs(title = "Medias Estimadas por Tratamiento con Letras de Tukey",
       subtitle = "Basado en el Modelo GLM Negativo Binomial",
       x = "Tratamiento",
       y = "Media Estimada de la Respuesta (con IC al 95%)") +
  
  # Tema
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

# 4. Imprimir el gráfico
print(grafico_tukey_nb)

